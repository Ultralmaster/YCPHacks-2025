ChatGPT prompts:


Prompt 1 (Chat A):



what are some effective ways to design user interfaces to increase user experience




Prompt 2 (Chat A):



yes




Prompt 3 (Chat A):



bullet point list




Prompt 4 (Chat A):



yes and use color theory and other art and design techniques




Prompt 5 (Chat B):



using the passage, prompt, and checklist below, create detailed steps for making the frontend only using pyqt5, python gui, and rpy2 that will access backend R functions, including step by step setup and breaking down problems to smaller and easier problems. the backend will not be done by me. i will not be doing the graphing.


Passage:

The Schneider Prize for Technology Innovation
(L-R) Frank Schneider, US Army; Dr. Tony Schneider, US Army Air Corps; Dr. Henry Schneider, US Marines; Edward A. Schneider, Jr, US Navy
The Schneider Prize for Technology Innovation was founded in 2017 to honor the accomplishments of the Schneider family of York
County, PA. Four brothers from York enlisted in the four branches of the military during World War II, while their sisters and parents
served at home. The brothers returned to become scientists, engineers and civil servants, making their mark on our community.
This prize honors their familyâ€™s achievements in our community and will be awarded to a Hack that results in ideas and innovations
for communicating and educating about specific technology.
In 2018, the prize was offered to the developer or team of developers that could improve upon the use of our current Grease ThiefÂ®
technology. The winning team shared the $1000 prize for their coding design and solution for creation of a criteria data set that
generated actions based on lubricant color changes. This led to our current patented Grease Thief Colorimeter that customers can
use on-site to analyze and quantify color changes in grease.
In 2021, the Schneider Prize addressed using a Raspberry Pi to develop a program to connect and collect data from multiple devices
(such as sensors, scales, barcode scanners, any student designed device, etc) to be uploaded to a website via a HTTP request. The
winning entry was able to demonstrate a design linked to their previous work as an intern in the York College Manufacturing
Fellowship grant project.
The challenge of the 2025 Schneider Prize for Technology Innovation will be:
Create a software solution that can take a baseline and multiple sample CSV files as input, superimpose the baseline
CSV with x number of sample CSVs onto x total graphs, and batch save the generated graphs to a desired location on
the file path. More information and instructions about this are offered on the back of this page.
MRG Labs designs instrument solutions for deployment in analytical laboratories and for end-users as mini-lab solutions, allowing
the evaluation of greases sampled from machinery to determine grease condition, contamination levels, and equipment health. As a
part of this process devices are often integrated into forms of automation that must receive and handle data output from these
devices. Currently York College is collaborating with MRG Labs for a Manufacturing Fellowship funded by a Pennsylvania state grant.
This Fellowship builds on existing efforts to automate laboratory operations, namely the Grease Monkey, a robotic setup that scans,
masses, assesses ferrous debris, measures color, and uploads the data to a website, MRG LIMS. Each teamâ€™s solution will be judged
on design, execution, and creativity. The team that makes the best application will receive a $1000 Grand Prize. If a second worthy
submittal is received, a Reserve Prize of $500 will also be awarded.
More information can be provided and questions can be answered in a brainstorming session given by JD Brown Center for
Entrepreneurship Center member MRG Labs during the Hackathon. Insight will be provided by Rich Wurzbach (President), Andrew
Mott (Reliability Engineer) and Dylan Kletzing (Lab Manager). Good Luck to all the Hackathon participants!
Example final graph:
Program Flow chart:
Other Requirements:
â€¢ Input:
o Baseline
â–ª Line graph: Green
â–ª Only one baseline is loaded at a time
â–ª When a baseline is loaded in, it should overwrite the last baseline, not append it to a list
o Sample
â–ª Line graph: Blue
â–ª Samples should be designed such that you can load in multiple at a time
â–ª Each time you load a set in, it should overwrite the last set
â€¢ Output:
o User must have the ability to decide where the images are saved
o Images must be saved in .png or .jpg formats
o Graphs must have a legend that shows the file name of the loaded in Baseline and Sample greases (similar to
whatâ€™s shown in the above graph)
â€¢ Extra Challenge:
o It would be nice to be able to have a graph generated on the GUI when a baseline is loaded in, then when a batch
of samples are loaded in, the user can select between samples and have the graph change with the selected
sample in real time.
â–ª With this addition, we still need to be able to batch save all graphs in one go, regardless of what is being
shown on the GUI.



Prompt:

â€¢ Input:
	o Baseline
		â–ª Line graph: Green
		â–ª Only one baseline is loaded at a time
		â–ª When a baseline is loaded in, it should overwrite the last baseline, not append it to a list
	o Sample
		â–ª Line graph: Blue
		â–ª Samples should be designed such that you can load in multiple at a time
		â–ª Each time you load a set in, it should overwrite the last set
â€¢ Output:
	o User must have the ability to decide where the images are saved
	o Images must be saved in .png or .jpg formats
	o Graphs must have a legend that shows the file name of the loaded in Baseline and Sample greases
â€¢ Extra Challenge:
	o It would be nice to be able to have a graph generated on the GUI when a baseline is loaded in, then when a batch of samples are loaded in, the user can select between samples and have the graph change with the selected sample in real time.
		â–ª With this addition, we still need to be able to batch save all graphs in one go, regardless of what is being shown on the GUI.



Checklist:

### **1. Users & Goals**

* Understand user needs, goals, and pain points
* Create personas and map user journeys
* Test early and often with real users

### **2. Usability**

* Keep interfaces simple, intuitive, and self-explanatory
* Maintain **consistency**: colors, typography, icons, spacing
* Provide immediate feedback on interactions
* Offer clear, constructive error messages

### **3. Visual Hierarchy & Layout**

* Use **size, contrast, and placement** to guide attention
* Apply **F-pattern or Z-pattern reading flow** for content
* Use **whitespace** to reduce clutter and highlight elements
* Maintain a clear **typography hierarchy** (headings, subheadings, body text)

### **4. Color Theory & Design**

* Use **contrast** for readability and focus (light text on dark or vice versa)
* Leverage **color psychology**:

  * Blue â†’ trust, calm
  * Red â†’ urgency, alert
  * Green â†’ success, progress
* Apply **complementary and analogous color schemes** for harmony
* Use **accent colors** to highlight CTAs (calls-to-action)
* Ensure high contrast for text and important elements

### **5. Navigation & Flow**

* Intuitive menus, tabs, and buttons
* Minimize steps to complete tasks
* Include breadcrumbs, progress bars, or indicators
* Maintain **predictable patterns** users recognize

### **6. Micro-Interactions & Emotional Design**

* Subtle animations for feedback (hover, click, loading)
* Delight users with small surprises (e.g., transitions, color shifts)
* Maintain **visual rhythm and balance** to keep the interface comfortable

### **7. Performance & Responsiveness**

* Optimize loading times
* Ensure smooth transitions and animations
* Test responsiveness on desktop, tablet, and mobile

### **8. Cognitive Load**

* Chunk content into digestible pieces
* Use **progressive disclosure** to hide advanced options
* Make interactions predictable and consistent

---

ðŸ’¡ **Quick Tips Using Art & Design Principles:**

* **Rule of Thirds:** Position key UI elements in thirds for natural focus.
* **Gestalt Principles:** Group related elements visually (proximity, similarity, closure).
* **Contrast & Balance:** Use contrasting colors and weight for emphasis; balance elements for harmony.
* **Whitespace = Luxury:** Donâ€™t fear empty spaceâ€”it improves focus and comprehension.




Prompt 6 (Chat B):



5) i want to remove the "mocks" folder and the "assets" folder




Prompt 7 (Chat B):



4) can you write it out




Prompt 8 (Chat B):



can you put it in a .md file




Prompt 9 (Chat B):



6) can you help me write it




Prompt 10 (Chat B):



step 6, can you help me write it




Prompt 11 (Chat B):



which script file do i put this in




Prompt 12 (Chat B):



yes




Prompt 13 (Chat B):



that doesnt look right, it's shorter than the original




Prompt 14 (Chat B):



step 8, can you write it




Prompt 15 (Chat B):



yes and where would these go




Prompt 16 (Chat B):



can you add step 8 to the script files




Prompt 17 (Chat B):



this is smaller than the one you previously wrote




Prompt 18 (Chat B):



this one is still shorter, by 12 lines




Prompt 19 (Chat B):



step 9, generate a few csv files that fit your criteria




Prompt 20 (Chat B):



batch save did not work




Prompt 21 (Chat B):



python mock fallback, the terminal outputted: "QThread: Destroyed while thread is still running"
the output folder did not exist 




Prompt 22 (Chat B):



Traceback (most recent call last):
  File "c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\main.py", line 461, in batch_save
    self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)       
                        ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^       
TypeError: BatchSaveWorker.__init__() missing 1 required positional argument: 'r_funcs'




Prompt 23 (Chat B):



the folder the files were saved in was created 3 folders above where it was supposed to be




Prompt 24 (Chat B):



it still outputs it 3 folders above and the main.py does not have .. at all except in places with ...




Prompt 25 (Chat B):



i can choose the output location (using the ui), but the preview_temp.png still outputs 3 folders above




Prompt 26 (Chat B):



here is my current main.py:

"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]
DEFAULT_SAVE_DIR = str(Path.home() / "schneider_output")
TEMP_PREVIEW_PATH = str(Path(DEFAULT_SAVE_DIR) / "preview_temp.png")
# -------------------------

# Always use main.py's folder as the base directory
APP_ROOT = os.path.dirname(os.path.abspath(__file__))
os.chdir(APP_ROOT)

# -------------------------
# Attempt rpy2 integration (optional)
# -------------------------
USE_R = False
r_preview = None
r_batch = None
try:
    from rpy2 import robjects
    # helper to try to load functions from R global env
    def try_get_r_funcs():
        global r_preview, r_batch
        g = robjects.globalenv
        has_preview = 'preview_plot' in g
        has_batch = 'batch_save_plots' in g
        if has_preview:
            r_preview = g['preview_plot']
        if has_batch:
            r_batch = g['batch_save_plots']
        return has_preview or has_batch

    # attempt detection (user can always source a script later)
    if try_get_r_funcs():
        USE_R = True
except Exception:
    USE_R = False
# -------------------------

# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path)
            numeric_cols = df.select_dtypes(include='number').columns
            if len(numeric_cols) == 0:
                # fallback generate synthetic
                x = np.linspace(0, 1, 100)
                y = np.random.random(100)
                return x, y
            col = numeric_cols[0]
            return df.index.values, df[col].values
        except Exception:
            x = np.linspace(0, 1, 100)
            y = np.random.random(100)
            return x, y

    plt.figure(figsize=(6,4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)
    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    plt.savefig(out_path)
    plt.close()
    return out_path
# -------------------------

# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout()
        central.setLayout(main_layout)

        # Left: controls (inputs)
        left = QVBoxLayout()
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.clicked.connect(self.load_baseline)
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.clicked.connect(self.load_samples)
        left.addWidget(btn_load_samples)

        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        left.addWidget(self.out_edit)
        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        left.addWidget(btn_choose_out)

        left.addWidget(QLabel("Image format:"))
        self.format_combo = QComboBox()
        self.format_combo.addItems(SUPPORTED_EXTS)
        try:
            idx = SUPPORTED_EXTS.index(self.image_ext)
        except Exception:
            idx = 0
        self.format_combo.setCurrentIndex(idx)
        self.format_combo.currentTextChanged.connect(self.format_changed)
        left.addWidget(self.format_combo)

        # Button to source an R script at runtime (optional)
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.clicked.connect(self.load_r_backend)
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # Middle: preview area
        mid = QVBoxLayout()
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet("background: #fafafa; border: 1px solid #ccc;")
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        mid.addWidget(self.preview_label, 8)

        # Quick buttons
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        mid.addWidget(btn_preview_selected)

        main_layout.addLayout(mid, 3)

        # Right: sample list + actions
        right = QVBoxLayout()
        right.addWidget(QLabel("Samples:"))
        self.sample_list = QListWidget()
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)  # auto-preview on selection
        right.addWidget(self.sample_list, 6)

        btn_remove = QPushButton("Remove selected sample")
        btn_remove.clicked.connect(self.remove_selected_sample)
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.clicked.connect(self.batch_save)
        right.addWidget(btn_batch)

        main_layout.addLayout(right, 1)

        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.statusBar().addPermanentWidget(self.progress, 1)
        self.status_message = QLabel("Ready")
        self.statusBar().addPermanentWidget(self.status_message, 3)

    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")
            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)

    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")
            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)

    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        if not USE_R:
            QMessageBox.information(self, "rpy2 unavailable", "rpy2 is not available in this Python environment.")
            return
        path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
        if not path:
            return
        try:
            robjects.r['source'](str(path))
            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']
            QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
            self.status_message.setText("R backend loaded")
        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R file:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        # If cached preview exists for current selection, show scaled pixmap
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s, TEMP_PREVIEW_PATH if os.path.exists(TEMP_PREVIEW_PATH) else None)
        else:
            # baseline-only preview
            preview_path = TEMP_PREVIEW_PATH if os.path.exists(TEMP_PREVIEW_PATH) else None
        if preview_path:
            self.show_image_in_preview(preview_path)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return

        # If sample_path is already cached, show immediately
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return

        # Determine where to write preview
        os.makedirs(os.path.dirname(TEMP_PREVIEW_PATH), exist_ok=True)
        out_path = TEMP_PREVIEW_PATH
        try:
            # Try calling R preview if available
            if USE_R and self.r_funcs.get('preview'):
                try:
                    # R function is expected to write the out_path image
                    # Pass empty string for sample if None per contract
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        # cache per sample
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated (R)")
                        return
                except Exception:
                    # fall back to python mock preview
                    pass

            # Fallback to python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                # for each sample we'll store a distinct preview file to avoid clobbering if desired.
                # Here we store the same TEMP_PREVIEW_PATH for simplicity; caching key points to it.
                self._preview_cache[sample_path] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated (mock)")
        except Exception as e:
            tb = traceback.format_exc()
            QMessageBox.critical(self, "Preview error", f"Could not generate preview:\n{e}\n{tb}")
            self.status_message.setText("Preview error")

    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = self.format_combo.currentText() or DEFAULT_IMAGE_EXT

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()





Prompt 27 (Chat B):



5) TEMP_PREVIEW_PATH was not found in the entire file
6.1) how do i confirm in the terminal




Prompt 28 (Chat B):



5) it does not exist in the file, i used ctrl+f




Prompt 29 (Chat B):



it does not exist in the file at all, not even in the functions you mentioned:



"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional)
# -------------------------
USE_R = False
r_preview = None
r_batch = None
try:
    from rpy2 import robjects
    # helper to try to load functions from R global env
    def try_get_r_funcs():
        global r_preview, r_batch
        g = robjects.globalenv
        has_preview = 'preview_plot' in g
        has_batch = 'batch_save_plots' in g
        if has_preview:
            r_preview = g['preview_plot']
        if has_batch:
            r_batch = g['batch_save_plots']
        return has_preview or has_batch

    # attempt detection (user can always source a script later)
    if try_get_r_funcs():
        USE_R = True
except Exception:
    USE_R = False
# -------------------------

# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path)
            numeric_cols = df.select_dtypes(include='number').columns
            if len(numeric_cols) == 0:
                # fallback generate synthetic
                x = np.linspace(0, 1, 100)
                y = np.random.random(100)
                return x, y
            col = numeric_cols[0]
            return df.index.values, df[col].values
        except Exception:
            x = np.linspace(0, 1, 100)
            y = np.random.random(100)
            return x, y

    plt.figure(figsize=(6,4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)
    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    plt.savefig(out_path)
    plt.close()
    return out_path
# -------------------------

# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout()
        central.setLayout(main_layout)

        # Left: controls (inputs)
        left = QVBoxLayout()
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.clicked.connect(self.load_baseline)
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.clicked.connect(self.load_samples)
        left.addWidget(btn_load_samples)

        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        left.addWidget(self.out_edit)
        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        left.addWidget(btn_choose_out)

        left.addWidget(QLabel("Image format:"))
        self.format_combo = QComboBox()
        self.format_combo.addItems(SUPPORTED_EXTS)
        try:
            idx = SUPPORTED_EXTS.index(self.image_ext)
        except Exception:
            idx = 0
        self.format_combo.setCurrentIndex(idx)
        self.format_combo.currentTextChanged.connect(self.format_changed)
        left.addWidget(self.format_combo)

        # Button to source an R script at runtime (optional)
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.clicked.connect(self.load_r_backend)
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # Middle: preview area
        mid = QVBoxLayout()
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet("background: #fafafa; border: 1px solid #ccc;")
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        mid.addWidget(self.preview_label, 8)

        # Quick buttons
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        mid.addWidget(btn_preview_selected)

        main_layout.addLayout(mid, 3)

        # Right: sample list + actions
        right = QVBoxLayout()
        right.addWidget(QLabel("Samples:"))
        self.sample_list = QListWidget()
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)  # auto-preview on selection
        right.addWidget(self.sample_list, 6)

        btn_remove = QPushButton("Remove selected sample")
        btn_remove.clicked.connect(self.remove_selected_sample)
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.clicked.connect(self.batch_save)
        right.addWidget(btn_batch)

        main_layout.addLayout(right, 1)

        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.statusBar().addPermanentWidget(self.progress, 1)
        self.status_message = QLabel("Ready")
        self.statusBar().addPermanentWidget(self.status_message, 3)

    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")
            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)

    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")
            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)

    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        if not USE_R:
            QMessageBox.information(self, "rpy2 unavailable", "rpy2 is not available in this Python environment.")
            return
        path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
        if not path:
            return
        try:
            robjects.r['source'](str(path))
            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']
            QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
            self.status_message.setText("R backend loaded")
        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R file:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return

        # If sample_path is already cached, show immediately
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return

        # Determine where to write preview (project-local TEMP_DIR)
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        try:
            # Try calling R preview if available
            if USE_R and self.r_funcs.get('preview'):
                try:
                    # R function is expected to write the out_path image
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        # cache per sample
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated (R)")
                        return
                except Exception:
                    # fall back to python mock preview
                    pass

            # Fallback to python mock preview (writes to out_path in TEMP_DIR)
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated (mock)")
        except Exception as e:
            tb = traceback.format_exc()
            QMessageBox.critical(self, "Preview error", f"Could not generate preview:\n{e}\n{tb}")
            self.status_message.setText("Preview error")


    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = self.format_combo.currentText() or DEFAULT_IMAGE_EXT

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()





Prompt 30 (Chat B):



1:

PS C:\WINDOWS\system32> cd "C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025"
PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> python main.py
Traceback (most recent call last):
  File "C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\main.py", line 21, in <module>
    from PyQt5.QtWidgets import (
    ...<3 lines>...
    )
ModuleNotFoundError: No module named 'PyQt5'




Prompt 31 (Chat B):



step 3) environment & install steps:
PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> python -m pip install --upgrade pip
Defaulting to user installation because normal site-packages is not writeable
Requirement already satisfied: pip in c:\python314\lib\site-packages (25.2)
Collecting pip
  Using cached pip-25.3-py3-none-any.whl.metadata (4.7 kB)
Using cached pip-25.3-py3-none-any.whl (1.8 MB)
Installing collected packages: pip
  WARNING: The scripts pip.exe, pip3.14.exe and pip3.exe are installed in 'C:\Users\yfedd\AppData\Roaming\Python\Python314\Scripts' which is not on PATH.
  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
Successfully installed pip-25.3

[notice] A new release of pip is available: 25.2 -> 25.3
[notice] To update, run: python.exe -m pip install --upgrade pip




Prompt 32 (Chat B):



are numpy and fonttools still downloading

   â”â”â”â”â”â”â”â”â”â”â”â”â•¸â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  7/22 [numpy]  WARNING: The scripts f2py.exe and numpy-config.exe are installed in 'C:\Users\yfedd\AppData\Roaming\Python\Python314\Scripts' which is not on PATH.
  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•ºâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” 10/22 [fonttools]  WARNING: The scripts fonttools.exe, pyftmerge.exe, pyftsubset.exe and ttx.exe are installed in 'C:\Users\yfedd\AppData\Roaming\Python\Python314\Scripts' which is not on PATH.
  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
Successfully installed MarkupSafe-3.0.3 cffi-2.0.0 contourpy-1.3.3 cycler-0.12.1 fonttools-4.60.1 jinja2-3.1.6 kiwisolver-1.4.9 matplotlib-3.10.7 numpy-2.3.4 packaging-25.0 pandas-2.3.3 pillow-12.0.0 pycparser-2.23 pyparsing-3.2.5 python-dateutil-2.9.0.post0 pytz-2025.2 rpy2-3.6.4 rpy2-rinterface-3.6.3 rpy2-robjects-3.6.3 six-1.17.0 tzdata-2025.2 tzlocal-5.3.1




Prompt 33 (Chat B):



in the problems section of vscode:
Import "pandas" could not be resolved from source Pylance(reportMissingModuleSource) [Ln 29, Col 8]
Import "rpy2" could not be resolved Pylance(reportMissinglmports) [Ln 83, Col 10]
Import "matplotlib" could not be resolved from source Pylance(reportMissingModuleSource) [Ln 111, Col 12]
Import "matplotlib.pyplot" could not be resolved from source Pylance(reportMissingModuleSource) [Ln 113, Col 12]
Import "numpy" could not be resolved Pylance(repoftMissinglmports) [Ln 114, Col 12]




Prompt 34 (Chat B):



yes




Prompt 35 (Chat B):



add r to system path is not on there, which folder should i add manually




Prompt 36 (Chat B):



PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> R --version 
R : Cannot locate the history for command line --version.
At line:1 char:1
+ R --version
+ ~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (--version:String) [Invoke-History], ArgumentException
    + FullyQualifiedErrorId : InvokeHistoryNoHistoryForCommandline,Microsoft.PowerShell.Commands.InvokeHistoryC  
   ommand





Prompt 37 (Chat B):



yes




Prompt 38 (Chat B):



i did those, it still doesn't work:

PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> "C:\Program Files\R\R-4.5.2\bin\Rscript.exe" --version
At line:1 char:48
+ "C:\Program Files\R\R-4.5.2\bin\Rscript.exe" --version
+                                                ~~~~~~~
Unexpected token 'version' in expression or statement.
At line:1 char:1
+ "C:\Program Files\R\R-4.5.2\bin\Rscript.exe" --version
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The '--' operator works only on variables or on properties.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : UnexpectedToken
	
	
	
	
Prompt 39 (Chat B):



yes




Prompt 40 (Chat B):



python finds r, and the graphing in the application doesn't work, can you check the main.py script to find out if the issue is displaying the graph or if the issue is with the graphing




Prompt 41 (Chat B):



def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return

        # If sample_path is already cached, show immediately
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return

        # Determine where to write preview (project-local TEMP_DIR)
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        try:
            # Try calling R preview if available
            if USE_R and self.r_funcs.get('preview'):
                try:
                    # R function is expected to write the out_path image
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        # cache per sample
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated (R)")
                        return
                except Exception:
                    # fall back to python mock preview
                    pass

            # Fallback to python mock preview (writes to out_path in TEMP_DIR)
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated (mock)")
        except Exception as e:
            tb = traceback.format_exc()
            QMessageBox.critical(self, "Preview error", f"Could not generate preview:\n{e}\n{tb}")
            self.status_message.setText("Preview error")


def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)


def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path)
            numeric_cols = df.select_dtypes(include='number').columns
            if len(numeric_cols) == 0:
                # fallback generate synthetic
                x = np.linspace(0, 1, 100)
                y = np.random.random(100)
                return x, y
            col = numeric_cols[0]
            return df.index.values, df[col].values
        except Exception:
            x = np.linspace(0, 1, 100)
            y = np.random.random(100)
            return x, y

    plt.figure(figsize=(6,4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)
    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    plt.savefig(out_path)
    plt.close()
    return out_path




Prompt 42 (Chat B):



the preview doesn't plot correctly




Prompt 43 (Chat B):



so that means that if the R code were to be added, it would show the correct graph?




Prompt 44 (Chat B):



what's supposed to go in the settings.py




Prompt 45 (Chat B):



use the checklist below to improve the UI/UX:


### **1. Users & Goals**

* Understand user needs, goals, and pain points
* Create personas and map user journeys
* Test early and often with real users

### **2. Usability**

* Keep interfaces simple, intuitive, and self-explanatory
* Maintain **consistency**: colors, typography, icons, spacing
* Provide immediate feedback on interactions
* Offer clear, constructive error messages

### **3. Visual Hierarchy & Layout**

* Use **size, contrast, and placement** to guide attention
* Apply **F-pattern or Z-pattern reading flow** for content
* Use **whitespace** to reduce clutter and highlight elements
* Maintain a clear **typography hierarchy** (headings, subheadings, body text)

### **4. Color Theory & Design**

* Use **contrast** for readability and focus (light text on dark or vice versa)
* Leverage **color psychology**:

  * Blue â†’ trust, calm
  * Red â†’ urgency, alert
  * Green â†’ success, progress
* Apply **complementary and analogous color schemes** for harmony
* Use **accent colors** to highlight CTAs (calls-to-action)
* Ensure high contrast for text and important elements

### **5. Navigation & Flow**

* Intuitive menus, tabs, and buttons
* Minimize steps to complete tasks
* Include breadcrumbs, progress bars, or indicators
* Maintain **predictable patterns** users recognize

### **6. Micro-Interactions & Emotional Design**

* Subtle animations for feedback (hover, click, loading)
* Delight users with small surprises (e.g., transitions, color shifts)
* Maintain **visual rhythm and balance** to keep the interface comfortable

### **7. Performance & Responsiveness**

* Optimize loading times
* Ensure smooth transitions and animations
* Test responsiveness on desktop, tablet, and mobile

### **8. Cognitive Load**

* Chunk content into digestible pieces
* Use **progressive disclosure** to hide advanced options
* Make interactions predictable and consistent

---

ðŸ’¡ **Quick Tips Using Art & Design Principles:**

* **Rule of Thirds:** Position key UI elements in thirds for natural focus.
* **Gestalt Principles:** Group related elements visually (proximity, similarity, closure).
* **Contrast & Balance:** Use contrasting colors and weight for emphasis; balance elements for harmony.
* **Whitespace = Luxury:** Donâ€™t fear empty spaceâ€”it improves focus and comprehension.




Prompt 46 (Chat B):



start by rewriting sections to incorporate number 1




Propmpt 47 (Chat B):



yes, but can you tell me where to put or overwrite with lines of code above and below where this modification would need to go




Prompt 48 (Chat B):



yes




Promopt 49 (Chat B):



are you sure color: #555 is correct




Prompt 50 (Chat B):



### **2. Usability**

* Keep interfaces simple, intuitive, and self-explanatory
* Maintain **consistency**: colors, typography, icons, spacing
* Provide immediate feedback on interactions
* Offer clear, constructive error messages




Prompt 51 (Chat B):



tell me where to put or overwrite with lines of code above and below where this modification would need to go




Prompt 52 (Chat B):



add 8 spaces before each line (this time only)




Prompt 53 (Chat B):



yes




Prompt 54 (Chat B):



could you remove 4 spaces form the front to make it 4 spaces




Prompt 55 (Chat B):



this one needs no indents, and how will this affect the ui when the R code is implemented




Prompt 56 (Chat B):



my python_mock_preview current looks like this, adjust the indentations:

def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path)
            numeric_cols = df.select_dtypes(include='number').columns
            if len(numeric_cols) == 0:
                # fallback generate synthetic
                x = np.linspace(0, 1, 100)
                y = np.random.random(100)
                return x, y
            col = numeric_cols[0]
            return df.index.values, df[col].values
        except Exception:
            x = np.linspace(0, 1, 100)
            y = np.random.random(100)
            return x, y

    plt.figure(figsize=(6,4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)
    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    plt.savefig(out_path)
    plt.close()
    return out_path
# -------------------------




Prompt 57 (Chat B):



yes




Prompt 58 (Chat B):



yes, and offer clear, constructive error messages




Prompt 59 (Chat B):



i tested it by inputting a .csv file with these contents, and it didn't graph the line properly and didnt show an error message:

0,1, 3
1,2,., 1
2,5
3,10
4,1.0.7
5,26
6,37..6, 
7,50
8,65
9,82
huh?, ,ed




Prompt 60 (Chat B):



tell me specifically where to place it and have it tell the user the malformed files




Prompt 61 (Chat B):



the error message seems incorrect, and it doesn't list all the files that are causing problems, having one malformed stops other non-malformed files if the baseline isn't loaded first:

Could not generate preview:
Malformed CSV C:/Users/yfedd/Downloads/hackathon/YCP
Hacks 2025/invalid file.csv': Error tokenizing data. C error:
Expected 3 fields in line 2, saw 4




Prompt 62 (Chat B):



it still says "Expected 3 fields in line 2, saw 4" even though it's supposed to only have two fields every row, the error appears once when malformed files are clicked on the right area, only one problematic file is listed when multiple are selected




Prompt 63 (Chat B):



start step 3:
### **3. Visual Hierarchy & Layout**
* Use **size, contrast, and placement** to guide attention
* Apply **F-pattern or Z-pattern reading flow** for content
* Use **whitespace** to reduce clutter and highlight elements
* Maintain a clear **typography hierarchy** (headings, subheadings, body text)




Prompt 64 (Chat B):



here's the main.py for reference:


"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional)
# -------------------------
USE_R = False
r_preview = None
r_batch = None
try:
    from rpy2 import robjects
    # helper to try to load functions from R global env
    def try_get_r_funcs():
        global r_preview, r_batch
        g = robjects.globalenv
        has_preview = 'preview_plot' in g
        has_batch = 'batch_save_plots' in g
        if has_preview:
            r_preview = g['preview_plot']
        if has_batch:
            r_batch = g['batch_save_plots']
        return has_preview or has_batch

    # attempt detection (user can always source a script later)
    if try_get_r_funcs():
        USE_R = True
except Exception:
    USE_R = False
# -------------------------

# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout()
        central.setLayout(main_layout)

        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # Load baseline CSV
        btn_load_base = QPushButton("Load Baseline CSV")  # Clear, self-explanatory
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        left.addWidget(btn_load_base)

        # Load multiple sample CSVs
        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        left.addWidget(btn_load_samples)

        # Output folder
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)  # Prevent manual input errors
        left.addWidget(self.out_edit)
        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        left.addWidget(btn_choose_out)

        # Image format selection
        left.addWidget(QLabel("Image format:"))
        self.format_combo = QComboBox()
        self.format_combo.addItems(SUPPORTED_EXTS)
        try:
            idx = SUPPORTED_EXTS.index(self.image_ext)
        except Exception:
            idx = 0
        self.format_combo.setCurrentIndex(idx)
        self.format_combo.currentTextChanged.connect(self.format_changed)
        left.addWidget(self.format_combo)

        # Optional R backend loader
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background: #fafafa; border: 1px solid #ccc; font-size: 14px; color: #333;"
        )
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        mid.addWidget(self.preview_label, 8)

        # Preview button
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        mid.addWidget(btn_preview_selected)

        main_layout.addLayout(mid, 3)



        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("Samples:"))

        # Sample list
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet("font-size: 13px; color: #333; padding: 3px;")
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Remove selected sample
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        right.addWidget(btn_remove)

        # Batch save all graphs
        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        right.addWidget(btn_batch)

        main_layout.addLayout(right, 1)



        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet("color: #555; font-size: 13px;")
        self.statusBar().addPermanentWidget(self.status_message, 3)


    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")
            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)

    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")
            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)

    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        if not USE_R:
            QMessageBox.information(self, "rpy2 unavailable", "rpy2 is not available in this Python environment.")
            return
        path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
        if not path:
            return
        try:
            robjects.r['source'](str(path))
            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']
            QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
            self.status_message.setText("R backend loaded")
        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R file:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = self.format_combo.currentText() or DEFAULT_IMAGE_EXT

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()




Prompt 65 (Chat B):



increase clarity in instructions




Prompt 66 (Chat B):



use other lines of code as references




Prompt 67 (Chat B):



do i replace or do i add and those lines are not where you say they are




Prompt 68 (Chat B):



yes:

### **4. Color Theory & Design**

* Use **contrast** for readability and focus (light text on dark or vice versa)
* Leverage **color psychology**:

  * Blue â†’ trust, calm
  * Red â†’ urgency, alert
  * Green â†’ success, progress
* Apply **complementary and analogous color schemes** for harmony
* Use **accent colors** to highlight CTAs (calls-to-action)
* Ensure high contrast for text and important elements




Prompt 69 (Chat B):



no, it might create confusion, continue using the anchor + end + replacement block format. start step 5:
### **5. Navigation & Flow**
* Intuitive menus, tabs, and buttons
* Minimize steps to complete tasks
* Include breadcrumbs, progress bars, or indicators
* Maintain **predictable patterns** users recognize




Prompt 70 (Chat B):



"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional)
# -------------------------
USE_R = False
r_preview = None
r_batch = None
try:
    from rpy2 import robjects
    # helper to try to load functions from R global env
    def try_get_r_funcs():
        global r_preview, r_batch
        g = robjects.globalenv
        has_preview = 'preview_plot' in g
        has_batch = 'batch_save_plots' in g
        if has_preview:
            r_preview = g['preview_plot']
        if has_batch:
            r_batch = g['batch_save_plots']
        return has_preview or has_batch

    # attempt detection (user can always source a script later)
    if try_get_r_funcs():
        USE_R = True
except Exception:
    USE_R = False
# -------------------------

# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout()
        central.setLayout(main_layout)

        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        left.addWidget(QLabel("<b>Data Inputs</b>"))
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_samples)

        left.setSpacing(12)
        left.setContentsMargins(10, 10, 10, 10)

        # SECTION: Output Settings
        left.addSpacing(8)
        left.addWidget(QLabel("<b>Output Settings</b>"))
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_choose_out)

        left.addWidget(QLabel("Image format:"))
        self.format_combo = QComboBox()
        self.format_combo.addItems(SUPPORTED_EXTS)
        try:
            idx = SUPPORTED_EXTS.index(self.image_ext)
        except Exception:
            idx = 0
        self.format_combo.setCurrentIndex(idx)
        self.format_combo.currentTextChanged.connect(self.format_changed)
        self.format_combo.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.format_combo)

        # SECTION: Advanced (optional)
        left.addSpacing(6)
        left.addWidget(QLabel("<b>Advanced (optional)</b>"))
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        btn_load_r.setStyleSheet(
            "background-color: #17A2B8; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Preview display
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ccc; font-size: 16px; color: #111;"
        )
        self.preview_label.setMinimumHeight(300)
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)

        # Quick action
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        mid.addWidget(btn_preview_selected)

        # Small informative line under preview
        self.preview_status = QLabel("No preview yet")
        self.preview_status.setStyleSheet("color: #555; font-size: 12px;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        mid.addWidget(self.preview_status)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("<b>Sample Files</b>"))

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 13px; padding: 6px; border: 1px solid #ccc; background-color: #fefefe; color: #111;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_batch)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #333; font-size: 12px;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)


        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumWidth(200)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 13px; font-weight: bold; color: #111;"
        )
        self.statusBar().addPermanentWidget(self.status_message, 3)




    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")
            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)

    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")
            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)

    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        if not USE_R:
            QMessageBox.information(self, "rpy2 unavailable", "rpy2 is not available in this Python environment.")
            return
        path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
        if not path:
            return
        try:
            robjects.r['source'](str(path))
            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']
            QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
            self.status_message.setText("R backend loaded")
        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R file:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = self.format_combo.currentText() or DEFAULT_IMAGE_EXT

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()




Prompt 71 (Chat B):



that's the code after applying step 4. apply step 5




Prompt 72 (Chat B):



that anchor does not exist




Prompt 73 (Chat B):



change the dropdown from the image format into two buttons and the selection above those buttons. change button colors to indicate selection




Prompt 74 (Chat B):



here's the new main.py:

"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional)
# -------------------------
USE_R = False
r_preview = None
r_batch = None
try:
    from rpy2 import robjects
    # helper to try to load functions from R global env
    def try_get_r_funcs():
        global r_preview, r_batch
        g = robjects.globalenv
        has_preview = 'preview_plot' in g
        has_batch = 'batch_save_plots' in g
        if has_preview:
            r_preview = g['preview_plot']
        if has_batch:
            r_batch = g['batch_save_plots']
        return has_preview or has_batch

    # attempt detection (user can always source a script later)
    if try_get_r_funcs():
        USE_R = True
except Exception:
    USE_R = False
# -------------------------

# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout()
        central.setLayout(main_layout)

        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        left.addWidget(QLabel("<b>Data Inputs</b>"))
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_samples)

        left.setSpacing(12)
        left.setContentsMargins(10, 10, 10, 10)

        # SECTION: Output Settings
        left.addSpacing(8)
        left.addWidget(QLabel("<b>Output Settings</b>"))
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_choose_out)

        left.addWidget(QLabel("Image format:"))
        self.format_combo = QComboBox()
        self.format_combo.addItems(SUPPORTED_EXTS)
        try:
            idx = SUPPORTED_EXTS.index(self.image_ext)
        except Exception:
            idx = 0
        self.format_combo.setCurrentIndex(idx)
        self.format_combo.currentTextChanged.connect(self.format_changed)
        self.format_combo.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.format_combo)

        # SECTION: Advanced (optional)
        left.addSpacing(6)
        left.addWidget(QLabel("<b>Advanced (optional)</b>"))
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        btn_load_r.setStyleSheet(
            "background-color: #17A2B8; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Preview display
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ccc; font-size: 16px; color: #111;"
        )
        self.preview_label.setMinimumHeight(300)
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)

        # Quick action
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        mid.addWidget(btn_preview_selected)

        # Small informative line under preview
        self.preview_status = QLabel("No preview yet")
        self.preview_status.setStyleSheet("color: #555; font-size: 12px;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        mid.addWidget(self.preview_status)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("<b>Sample Files</b>"))

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 13px; padding: 6px; border: 1px solid #ccc; background-color: #fefefe; color: #111;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_batch)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #333; font-size: 12px;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)


        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumWidth(200)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 13px; font-weight: bold; color: #111;"
        )
        self.statusBar().addPermanentWidget(self.status_message, 3)




    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")
            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)

    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")
            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)

    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        if not USE_R:
            QMessageBox.information(self, "rpy2 unavailable", "rpy2 is not available in this Python environment.")
            return
        path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
        if not path:
            return
        try:
            robjects.r['source'](str(path))
            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']
            QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
            self.status_message.setText("R backend loaded")
        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R file:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = self.format_combo.currentText() or DEFAULT_IMAGE_EXT

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()




Prompt 75 (Chat B):



when the baseline is loaded, the "load baseline > select sample > generate preview" turns the "generate preview" green. when all sample files are removed, the "load baseline > select sample > generate preview" section does not highlight "select sample"




Prompt 76 (Chat B):



"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional)
# -------------------------
USE_R = False
r_preview = None
r_batch = None
try:
    from rpy2 import robjects
    # helper to try to load functions from R global env
    def try_get_r_funcs():
        global r_preview, r_batch
        g = robjects.globalenv
        has_preview = 'preview_plot' in g
        has_batch = 'batch_save_plots' in g
        if has_preview:
            r_preview = g['preview_plot']
        if has_batch:
            r_batch = g['batch_save_plots']
        return has_preview or has_batch

    # attempt detection (user can always source a script later)
    if try_get_r_funcs():
        USE_R = True
except Exception:
    USE_R = False
# -------------------------

# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)

        # MAIN CONTENT LAYOUTS
        # create the existing horizontal main layout (left / middle / right)
        main_layout = QHBoxLayout()

        # OUTER vertical layout holds breadcrumb nav on top and main_layout below
        outer_layout = QVBoxLayout()
        central.setLayout(outer_layout)

        # -----------------------
        # Breadcrumb / navigation bar (shows workflow stages)
        # -----------------------
        self.nav_stage1 = QLabel("â‘  Load Baseline")
        self.nav_stage2 = QLabel("â‘¡ Select Sample")
        self.nav_stage3 = QLabel("â‘¢ Generate Preview")

        for lbl in (self.nav_stage1, self.nav_stage2, self.nav_stage3):
            lbl.setStyleSheet(
                "font-weight: 600; color: #2b3a67; padding: 4px 8px; font-size: 12px;"
            )

        # small arrows between stages
        nav_bar = QHBoxLayout()
        nav_bar.addWidget(self.nav_stage1)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage2)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage3)
        nav_bar.addStretch()

        nav_widget = QWidget()
        nav_widget.setLayout(nav_bar)
        nav_widget.setStyleSheet("background-color: #eef2fa; border-radius: 6px; padding: 6px;")

        # add breadcrumb and the original main_layout into the outer layout
        outer_layout.addWidget(nav_widget)
        outer_layout.addLayout(main_layout)

        # simple progress label under the main layout (can be updated by actions)
        self.progress_label = QLabel("Progress: waiting for inputâ€¦")
        self.progress_label.setStyleSheet("color: #555; font-style: italic; padding-top:6px;")
        outer_layout.addWidget(self.progress_label)


        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        left.addWidget(QLabel("<b>Data Inputs</b>"))
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_samples)

        left.setSpacing(12)
        left.setContentsMargins(10, 10, 10, 10)

        # SECTION: Output Settings
        left.addSpacing(8)
        left.addWidget(QLabel("<b>Output Settings</b>"))
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_choose_out)

        # --- Image Format Selection (replaces dropdown) ---
        left.addWidget(QLabel("Select Image Format:"))

        format_button_layout = QHBoxLayout()
        self.format_buttons = {}

        def make_format_button(fmt):
            btn = QPushButton(fmt.upper())
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #e0e0e0;
                    border: 1px solid #ccc;
                    border-radius: 6px;
                    padding: 4px 10px;
                    font-weight: 600;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:checked {
                    background-color: #0078d7;
                    color: white;
                    border: 1px solid #005fa3;
                }
            """)
            btn.clicked.connect(lambda _, f=fmt: self.select_format(f))
            format_button_layout.addWidget(btn)
            self.format_buttons[fmt] = btn
        
        for fmt in SUPPORTED_EXTS:
            make_format_button(fmt)
        
        # Default selected format
        self.current_format = DEFAULT_IMAGE_EXT
        if self.current_format in self.format_buttons:
            self.format_buttons[self.current_format].setChecked(True)
        
        left.addLayout(format_button_layout)
        # --- End replacement ---


        # SECTION: Advanced (optional)
        left.addSpacing(6)
        left.addWidget(QLabel("<b>Advanced (optional)</b>"))
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        btn_load_r.setStyleSheet(
            "background-color: #17A2B8; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Preview display
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ccc; font-size: 16px; color: #111;"
        )
        self.preview_label.setMinimumHeight(300)
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)

        # Quick action
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        mid.addWidget(btn_preview_selected)

        # Small informative line under preview
        self.preview_status = QLabel("No preview yet")
        self.preview_status.setStyleSheet("color: #555; font-size: 12px;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        mid.addWidget(self.preview_status)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("<b>Sample Files</b>"))

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 13px; padding: 6px; border: 1px solid #ccc; background-color: #fefefe; color: #111;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_batch)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #333; font-size: 12px;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)


        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumWidth(200)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 13px; font-weight: bold; color: #111;"
        )
        self.statusBar().addPermanentWidget(self.status_message, 3)




    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active = green
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            except Exception:
                pass

            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)


    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(paths)} sample(s) loaded â€” select one to preview")
            except Exception:
                pass

            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)


    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def select_format(self, fmt):
        """Handle image format button selection and update the current format."""
        self.current_format = fmt
        for f, btn in self.format_buttons.items():
            btn.setChecked(f == fmt)
        self.status_message.setText(f"Image format set to {fmt.upper()}")

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        if not USE_R:
            QMessageBox.information(self, "rpy2 unavailable", "rpy2 is not available in this Python environment.")
            return
        path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
        if not path:
            return
        try:
            robjects.r['source'](str(path))
            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']
            QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
            self.status_message.setText("R backend loaded")
        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R file:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        try:
                            self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                            self.progress_label.setText("Progress: preview generated (R)")
                        except Exception:
                            pass
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.progress_label.setText("Progress: preview generated (mock)")
            except Exception:
                pass

    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = getattr(self, "current_format", DEFAULT_IMAGE_EXT)

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()




Prompt 77 (Chat B):



it still doesn't work, lets work on it after we link R. how do i unpack a .rmd file with rstudio if the third line is "output: html_document"




Prompt 78 (Chat B):



how do i extract the directories




Prompt 79 (Chat B):



i have the .rmd file, and i need you to attach the r scripts to the frontend.


MRG - R Code Backend.Rmd:


---
title: "MRG"
output: html_document
date: "2025-11-08"
---

```{r}
initLib <- function(){
library(tidyverse)
library(stringr)
library(ggpubr)
library(cowplot)
getwd()
setwd("C:/Users/ultra/Documents/~Hackathons/YCPHacks/MRG")

}

initLib()
```

```{r}
parseCSV <- function(csvFile = NULL){
  return(read.csv(csvFile, 
                 header = TRUE,
                 sep = ",",
                 stringsAsFactors = FALSE,
                 skip = 1,
                 ) %>% lapply(as.double) %>% data.frame())
}

ggplotDPath <- function(parsed = NULL, label = "Comparee"){
  return(geom_path(data = parsed,
                                aes(x = cm.1, y = A,
                                colour = label),
                                show.legend = FALSE))
}
```

```{r}


setBaseLine <- function(fileInputRaw=NULL){
  p <- parseCSV(fileInputRaw)
  defaultFileName <<- fileInputRaw
  defaultMin <<- min(p$A)
  defaultMax <<- max(p$A)

  baselinePlot <- ggplot(p, aes(x = cm.1, y = A))+
            theme_pubr()+
            theme(axis.text.x = element_text(size = 8), legend.title = element_blank())+
            geom_path(aes(colour = defaultFileName), show.legend = TRUE)+
            scale_x_continuous(breaks = pretty(p$'cm.1', n = 20),
                              transform = "reverse")+
            xlab("Wavelength (cmâ»Â¹)")+
            ylab("Amplitude (A)")
            
           
  return(baselinePlot)
        
}



```


```{r}
addGraph <- function(base = baselinePlot, fileInput=NULL){
  label <- fileInput
  cols <- c()
  cols[defaultFileName] <- "#008000"
  cols[label] <- "#0000FF" 
  newGraph <- base + ggplotDPath(parseCSV(fileInput), label) +
                      scale_colour_manual(values = cols,
                                          name = "Name:")
  

  return(newGraph)
}
```



```{r}

collateFromCSV <- function(listInserted = NULL){
compareeCSVs <- listInserted
collatedGraph <- tibble(name = character(), plot = list())

for (i in compareeCSVs){
  if(i!=defaultFileName){
      iMax <- max((read.csv(i,skip=1))$A)
      newGraph <- addGraph(base=baselinePlot, fileInput=i)+
                  ggtitle(paste(defaultFileName, "vs", i, sep=" "))+
                  theme(plot.title = element_text(hjust = 0.5))+
                  scale_y_continuous(breaks = seq(
                                            floor  (defaultMin),
                                            ceiling(max(c(iMax,defaultMax))),
                                                    by = .5))+
                  labs(colour = "Name:")+
                  theme(legend.position = "bottom")
      
    collatedGraph <- collatedGraph %>% add_row(name = i,plot=list(newGraph))
    }
  }
return(collatedGraph)
}

```


```{r}
pullGraph <- function(selectName = NULL){
  return ((collatedGraph %>% filter(name==selectName) %>% pull(2))[[1]])
}
```


```{r}
saveGraph <- function(location = paste(getwd(),str_sub(Sys.time(), 1, 10), sep = "/"),
                      nameSelected = NULL,
                      dpiChosen = 320,
                      fileType = "png"){
  
  ggsave(filename = paste(defaultFileName, "_vs_", nameSelected, ".",fileType, sep = ""),
         plot = pullGraph(nameSelected),
         device = fileType,
         path = location,
         dpi = dpiChosen,
         create.dir = TRUE)
}

```



main.py:


"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional)
# -------------------------
USE_R = False
r_preview = None
r_batch = None
try:
    from rpy2 import robjects
    # helper to try to load functions from R global env
    def try_get_r_funcs():
        global r_preview, r_batch
        g = robjects.globalenv
        has_preview = 'preview_plot' in g
        has_batch = 'batch_save_plots' in g
        if has_preview:
            r_preview = g['preview_plot']
        if has_batch:
            r_batch = g['batch_save_plots']
        return has_preview or has_batch

    # attempt detection (user can always source a script later)
    if try_get_r_funcs():
        USE_R = True
except Exception:
    USE_R = False
# -------------------------

# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)

        # MAIN CONTENT LAYOUTS
        # create the existing horizontal main layout (left / middle / right)
        main_layout = QHBoxLayout()

        # OUTER vertical layout holds breadcrumb nav on top and main_layout below
        outer_layout = QVBoxLayout()
        central.setLayout(outer_layout)

        # -----------------------
        # Breadcrumb / navigation bar (shows workflow stages)
        # -----------------------
        self.nav_stage1 = QLabel("â‘  Load Baseline")
        self.nav_stage2 = QLabel("â‘¡ Select Sample")
        self.nav_stage3 = QLabel("â‘¢ Generate Preview")

        for lbl in (self.nav_stage1, self.nav_stage2, self.nav_stage3):
            lbl.setStyleSheet(
                "font-weight: 600; color: #2b3a67; padding: 4px 8px; font-size: 12px;"
            )

        # small arrows between stages
        nav_bar = QHBoxLayout()
        nav_bar.addWidget(self.nav_stage1)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage2)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage3)
        nav_bar.addStretch()

        nav_widget = QWidget()
        nav_widget.setLayout(nav_bar)
        nav_widget.setStyleSheet("background-color: #eef2fa; border-radius: 6px; padding: 6px;")

        # add breadcrumb and the original main_layout into the outer layout
        outer_layout.addWidget(nav_widget)
        outer_layout.addLayout(main_layout)

        # simple progress label under the main layout (can be updated by actions)
        self.progress_label = QLabel("Progress: waiting for inputâ€¦")
        self.progress_label.setStyleSheet("color: #555; font-style: italic; padding-top:6px;")
        outer_layout.addWidget(self.progress_label)


        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        left.addWidget(QLabel("<b>Data Inputs</b>"))
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_samples)

        left.setSpacing(12)
        left.setContentsMargins(10, 10, 10, 10)

        # SECTION: Output Settings
        left.addSpacing(8)
        left.addWidget(QLabel("<b>Output Settings</b>"))
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_choose_out)

        # --- Image Format Selection (replaces dropdown) ---
        left.addWidget(QLabel("Select Image Format:"))

        format_button_layout = QHBoxLayout()
        self.format_buttons = {}

        def make_format_button(fmt):
            btn = QPushButton(fmt.upper())
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #e0e0e0;
                    border: 1px solid #ccc;
                    border-radius: 6px;
                    padding: 4px 10px;
                    font-weight: 600;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:checked {
                    background-color: #0078d7;
                    color: white;
                    border: 1px solid #005fa3;
                }
            """)
            btn.clicked.connect(lambda _, f=fmt: self.select_format(f))
            format_button_layout.addWidget(btn)
            self.format_buttons[fmt] = btn
        
        for fmt in SUPPORTED_EXTS:
            make_format_button(fmt)
        
        # Default selected format
        self.current_format = DEFAULT_IMAGE_EXT
        if self.current_format in self.format_buttons:
            self.format_buttons[self.current_format].setChecked(True)
        
        left.addLayout(format_button_layout)
        # --- End replacement ---


        # SECTION: Advanced (optional)
        left.addSpacing(6)
        left.addWidget(QLabel("<b>Advanced (optional)</b>"))
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        btn_load_r.setStyleSheet(
            "background-color: #17A2B8; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Preview display
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ccc; font-size: 16px; color: #111;"
        )
        self.preview_label.setMinimumHeight(300)
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)

        # Quick action
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        mid.addWidget(btn_preview_selected)

        # Small informative line under preview
        self.preview_status = QLabel("No preview yet")
        self.preview_status.setStyleSheet("color: #555; font-size: 12px;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        mid.addWidget(self.preview_status)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("<b>Sample Files</b>"))

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 13px; padding: 6px; border: 1px solid #ccc; background-color: #fefefe; color: #111;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_batch)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #333; font-size: 12px;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)


        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumWidth(200)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 13px; font-weight: bold; color: #111;"
        )
        self.statusBar().addPermanentWidget(self.status_message, 3)




    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active = green
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            except Exception:
                pass

            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)


    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(paths)} sample(s) loaded â€” select one to preview")
            except Exception:
                pass

            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)


    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def select_format(self, fmt):
        """Handle image format button selection and update the current format."""
        self.current_format = fmt
        for f, btn in self.format_buttons.items():
            btn.setChecked(f == fmt)
        self.status_message.setText(f"Image format set to {fmt.upper()}")

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        if not USE_R:
            QMessageBox.information(self, "rpy2 unavailable", "rpy2 is not available in this Python environment.")
            return
        path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
        if not path:
            return
        try:
            robjects.r['source'](str(path))
            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']
            QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
            self.status_message.setText("R backend loaded")
        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R file:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

            # --- Breadcrumb / progress updates ---
            if not self.sample_paths:
                # No samples left: revert to baseline-only state
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # baseline = active
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            else:
                # Samples remain: highlight selection step
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(self.sample_paths)} sample(s) remaining â€” select one to preview")


    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        try:
                            self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                            self.progress_label.setText("Progress: preview generated (R)")
                        except Exception:
                            pass
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.progress_label.setText("Progress: preview generated (mock)")
            except Exception:
                pass

    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = getattr(self, "current_format", DEFAULT_IMAGE_EXT)

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()




Prompt 80 (Chat B):



step 2, no i do not have that function




Prompt 81 (Chat B):



when i click load r backend, it says "rpy2 is not available in this Python environment."




Prompt 82 (Chat B):



1:
sys.path = [
    'C:\\Users\\yfedd\\Downloads\\hackathon\\YCP Hacks 2025',
    'C:\\Python314\\python314.zip',
    'C:\\Python314\\DLLs',
    'C:\\Python314\\Lib',
    'C:\\Python314',
    'C:\\Users\\yfedd\\AppData\\Roaming\\Python\\Python314\\site-packages',
    'C:\\Python314\\Lib\\site-packages',
]
USER_BASE: 'C:\\Users\\yfedd\\AppData\\Roaming\\Python' (exists)
USER_SITE: 'C:\\Users\\yfedd\\AppData\\Roaming\\Python\\Python314\\site-packages' (exists)
ENABLE_USER_SITE: True

2:
PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> python -m pip show rpy2
Name: rpy2
Version: 3.6.4
Summary: Python interface to the R language (embedded R)
Home-page: https://rpy2.github.io
Author:
Author-email: Laurent Gautier <lgautier@gmail.com>
License-Expression: GPL-2.0-or-later
Location: C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages
Requires: packaging, rpy2-rinterface, rpy2-robjects
Required-by:

3:
PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> python -m pip install rpy2 --upgrade
Defaulting to user installation because normal site-packages is not writeable
Requirement already satisfied: rpy2 in c:\users\yfedd\appdata\roaming\python\python314\site-packages (3.6.4)
Requirement already satisfied: rpy2-rinterface>=3.6.3 in c:\users\yfedd\appdata\roaming\python\python314\site-packages (from rpy2) (3.6.3)
Requirement already satisfied: rpy2-robjects>=3.6.3 in c:\users\yfedd\appdata\roaming\python\python314\site-packages (from rpy2) (3.6.3)
Requirement already satisfied: packaging in c:\users\yfedd\appdata\roaming\python\python314\site-packages (from rpy2) (25.0)
Requirement already satisfied: cffi>=1.15.1 in c:\users\yfedd\appdata\roaming\python\python314\site-packages (from rpy2-rinterface>=3.6.3->rpy2) (2.0.0)
Requirement already satisfied: pycparser in c:\users\yfedd\appdata\roaming\python\python314\site-packages (from cffi>=1.15.1->rpy2-rinterface>=3.6.3->rpy2) (2.23)
Requirement already satisfied: jinja2 in c:\users\yfedd\appdata\roaming\python\python314\site-packages (from rpy2-robjects>=3.6.3->rpy2) (3.1.6)
Requirement already satisfied: tzlocal in c:\users\yfedd\appdata\roaming\python\python314\site-packages (from rpy2-robjects>=3.6.3->rpy2) (5.3.1)
Requirement already satisfied: MarkupSafe>=2.0 in c:\users\yfedd\appdata\roaming\python\python314\site-packages (from jinja2->rpy2-robjects>=3.6.3->rpy2) (3.0.3)
Requirement already satisfied: tzdata in c:\users\yfedd\appdata\roaming\python\python314\site-packages (from tzlocal->rpy2-robjects>=3.6.3->rpy2) (2025.2)




Prompt 83 (Chat B):



step 1: 
PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> R --version
R : Cannot locate the history for command line --version.
At line:1 char:1
+ R --version
+ ~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (--version:String) [Invoke-History], ArgumentException
    + FullyQualifiedErrorId : InvokeHistoryNoHistoryForCommandline,Microsoft.PowerShell.Commands.InvokeHistoryC  
   ommand

Step 2: it was already added in both system and user variables

Step 3: it prints the R version




Prompt 84 (Chat B):



2:
PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> & C:/Python314/python.exe "c:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/test.py"
'sh' is not recognized as an internal or external command,
operable program or batch file.
Error importing in API mode: ImportError('On Windows, cffi mode "ANY" is only "ABI".')
Trying to import in ABI mode.
Error in `geom_path()`:
! Problem while computing aesthetics.
i Error occurred in the 1st layer.
Caused by error:
! object 'cm.1' not found
Run `rlang::last_trace()` to see where the error occurred.
R callback write-console: Warning messages:

R callback write-console: 1:
R callback write-console: In min(p$A, na.rm = TRUE) :
R callback write-console:

R callback write-console:  no non-missing arguments to min; returning Inf

R callback write-console: 2:
R callback write-console: In max(p$A, na.rm = TRUE) :
R callback write-console:

R callback write-console:  no non-missing arguments to max; returning -Inf

Traceback (most recent call last):
  File "c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\test.py", line 7, in <module>
    preview("C:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/test baseline.csv", "C:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/test sample1.csv", "C:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/schneider_output/sample1.png")
    ~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\robjects\functions.py", line 208, in __call__
    return (super(SignatureTranslatedFunction, self)
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            .__call__(*args, **kwargs))
            ~~~~~~~~~^^^^^^^^^^^^^^^^^
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\robjects\functions.py", line 131, in __call__
    res = super(Function, self).__call__(*new_args, **new_kwargs)
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\rinterface_lib\conversion.py", line 46, in _
    cdata = function(*args, **kwargs)
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\rinterface\__init__.py", line 926, in __call__
    raise embedded.RRuntimeError(_rinterface._geterrmessage())
rpy2.rinterface_lib.embedded.RRuntimeError: Error in geom_path(aes(colour = defaultFileName), show.legend = TRUE) :

i Error occurred in the 1st layer.
Caused by error:
! object 'cm.1' not found

3:
same popup message

4:
can you be more specific




Prompt 85 (Chat B):



can you generate a few csv files that would work with the scripts




Prompt 86 (Chat B):



PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> & C:/Python314/python.exe "c:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/test.py"
'sh' is not recognized as an internal or external command,
operable program or batch file.
Error importing in API mode: ImportError('On Windows, cffi mode "ANY" is only "ABI".')
Trying to import in ABI mode.
Error in `geom_path()`:
! Problem while computing aesthetics.
i Error occurred in the 1st layer.
Caused by error:
! object 'cm.1' not found
Run `rlang::last_trace()` to see where the error occurred.
R callback write-console: Warning messages:

R callback write-console: 1:
R callback write-console: In min(p$A, na.rm = TRUE) :
R callback write-console:

R callback write-console:  no non-missing arguments to min; returning Inf

R callback write-console: 2:
R callback write-console: In max(p$A, na.rm = TRUE) :
R callback write-console:

R callback write-console:  no non-missing arguments to max; returning -Inf

Traceback (most recent call last):
  File "c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\test.py", line 7, in <module>
    preview("C:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/test baseline.csv", "C:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/test sample1.csv", "C:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/schneider_output/sample1.png")
    ~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\robjects\functions.py", line 208, in __call__
    return (super(SignatureTranslatedFunction, self)
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            .__call__(*args, **kwargs))
            ~~~~~~~~~^^^^^^^^^^^^^^^^^
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\robjects\functions.py", line 131, in __call__
    res = super(Function, self).__call__(*new_args, **new_kwargs)
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\rinterface_lib\conversion.py", line 46, in _
    cdata = function(*args, **kwargs)
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\rinterface\__init__.py", line 926, in __call__
    raise embedded.RRuntimeError(_rinterface._geterrmessage())
rpy2.rinterface_lib.embedded.RRuntimeError: Error in geom_path(aes(colour = defaultFileName), show.legend = TRUE) :

i Error occurred in the 1st layer.
Caused by error:
! object 'cm.1' not found




Project 87 (Chat B):



2: i added r in front of each file path's start quotes
PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> & C:/Python314/python.exe "c:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/test.py"
'sh' is not recognized as an internal or external command,
operable program or batch file.
Error importing in API mode: ImportError('On Windows, cffi mode "ANY" is only "ABI".')
Trying to import in ABI mode.
Error in `geom_path()`:
! Problem while computing aesthetics.
i Error occurred in the 1st layer.
Caused by error:
! object 'cm.1' not found
Run `rlang::last_trace()` to see where the error occurred.
R callback write-console: Warning messages:

R callback write-console: 1:
R callback write-console: In min(p$A, na.rm = TRUE) :
R callback write-console:

R callback write-console:  no non-missing arguments to min; returning Inf

R callback write-console: 2:
R callback write-console: In max(p$A, na.rm = TRUE) :
R callback write-console:

R callback write-console:  no non-missing arguments to max; returning -Inf

Traceback (most recent call last):
  File "c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\test.py", line 7, in <module>
    preview(r"C:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/test baseline.csv", r"C:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/test sample1.csv", r"C:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/schneider_output/sample1.png")
    ~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\robjects\functions.py", line 208, in __call__
    return (super(SignatureTranslatedFunction, self)
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            .__call__(*args, **kwargs))
            ~~~~~~~~~^^^^^^^^^^^^^^^^^
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\robjects\functions.py", line 131, in __call__
    res = super(Function, self).__call__(*new_args, **new_kwargs)
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\rinterface_lib\conversion.py", line 46, in _
    cdata = function(*args, **kwargs)
  File "C:\Users\yfedd\AppData\Roaming\Python\Python314\site-packages\rpy2\rinterface\__init__.py", line 926, in __call__
    raise embedded.RRuntimeError(_rinterface._geterrmessage())
rpy2.rinterface_lib.embedded.RRuntimeError: Error in geom_path(aes(colour = defaultFileName), show.legend = TRUE) :

i Error occurred in the 1st layer.
Caused by error:
! object 'cm.1' not found

3:
> baseline <- read.csv("C:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/test$
> head(baseline)
  cm.1    A
1 4000 0.12
2 3990 0.15
3 3980 0.18
4 3970 0.14
5 3960 0.11
6 3950 0.09




Prompt 88 (Chat B):



main.py:
"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional)
# -------------------------
USE_R = False
r_preview = None
r_batch = None
try:
    from rpy2 import robjects
    # helper to try to load functions from R global env
    def try_get_r_funcs():
        global r_preview, r_batch
        g = robjects.globalenv
        has_preview = 'preview_plot' in g
        has_batch = 'batch_save_plots' in g
        if has_preview:
            r_preview = g['preview_plot']
        if has_batch:
            r_batch = g['batch_save_plots']
        return has_preview or has_batch

    # attempt detection (user can always source a script later)
    if try_get_r_funcs():
        USE_R = True
except Exception:
    USE_R = False
# -------------------------

# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)

        # MAIN CONTENT LAYOUTS
        # create the existing horizontal main layout (left / middle / right)
        main_layout = QHBoxLayout()

        # OUTER vertical layout holds breadcrumb nav on top and main_layout below
        outer_layout = QVBoxLayout()
        central.setLayout(outer_layout)

        # -----------------------
        # Breadcrumb / navigation bar (shows workflow stages)
        # -----------------------
        self.nav_stage1 = QLabel("â‘  Load Baseline")
        self.nav_stage2 = QLabel("â‘¡ Select Sample")
        self.nav_stage3 = QLabel("â‘¢ Generate Preview")

        for lbl in (self.nav_stage1, self.nav_stage2, self.nav_stage3):
            lbl.setStyleSheet(
                "font-weight: 600; color: #2b3a67; padding: 4px 8px; font-size: 12px;"
            )

        # small arrows between stages
        nav_bar = QHBoxLayout()
        nav_bar.addWidget(self.nav_stage1)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage2)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage3)
        nav_bar.addStretch()

        nav_widget = QWidget()
        nav_widget.setLayout(nav_bar)
        nav_widget.setStyleSheet("background-color: #eef2fa; border-radius: 6px; padding: 6px;")

        # add breadcrumb and the original main_layout into the outer layout
        outer_layout.addWidget(nav_widget)
        outer_layout.addLayout(main_layout)

        # simple progress label under the main layout (can be updated by actions)
        self.progress_label = QLabel("Progress: waiting for inputâ€¦")
        self.progress_label.setStyleSheet("color: #555; font-style: italic; padding-top:6px;")
        outer_layout.addWidget(self.progress_label)


        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        left.addWidget(QLabel("<b>Data Inputs</b>"))
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_samples)

        left.setSpacing(12)
        left.setContentsMargins(10, 10, 10, 10)

        # SECTION: Output Settings
        left.addSpacing(8)
        left.addWidget(QLabel("<b>Output Settings</b>"))
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_choose_out)

        # --- Image Format Selection (replaces dropdown) ---
        left.addWidget(QLabel("Select Image Format:"))

        format_button_layout = QHBoxLayout()
        self.format_buttons = {}

        def make_format_button(fmt):
            btn = QPushButton(fmt.upper())
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #e0e0e0;
                    border: 1px solid #ccc;
                    border-radius: 6px;
                    padding: 4px 10px;
                    font-weight: 600;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:checked {
                    background-color: #0078d7;
                    color: white;
                    border: 1px solid #005fa3;
                }
            """)
            btn.clicked.connect(lambda _, f=fmt: self.select_format(f))
            format_button_layout.addWidget(btn)
            self.format_buttons[fmt] = btn
        
        for fmt in SUPPORTED_EXTS:
            make_format_button(fmt)
        
        # Default selected format
        self.current_format = DEFAULT_IMAGE_EXT
        if self.current_format in self.format_buttons:
            self.format_buttons[self.current_format].setChecked(True)
        
        left.addLayout(format_button_layout)
        # --- End replacement ---


        # SECTION: Advanced (optional)
        left.addSpacing(6)
        left.addWidget(QLabel("<b>Advanced (optional)</b>"))
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        btn_load_r.setStyleSheet(
            "background-color: #17A2B8; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Preview display
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ccc; font-size: 16px; color: #111;"
        )
        self.preview_label.setMinimumHeight(300)
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)

        # Quick action
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        mid.addWidget(btn_preview_selected)

        # Small informative line under preview
        self.preview_status = QLabel("No preview yet")
        self.preview_status.setStyleSheet("color: #555; font-size: 12px;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        mid.addWidget(self.preview_status)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("<b>Sample Files</b>"))

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 13px; padding: 6px; border: 1px solid #ccc; background-color: #fefefe; color: #111;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_batch)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #333; font-size: 12px;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)


        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumWidth(200)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 13px; font-weight: bold; color: #111;"
        )
        self.statusBar().addPermanentWidget(self.status_message, 3)




    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active = green
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            except Exception:
                pass

            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)


    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(paths)} sample(s) loaded â€” select one to preview")
            except Exception:
                pass

            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)


    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def select_format(self, fmt):
        """Handle image format button selection and update the current format."""
        self.current_format = fmt
        for f, btn in self.format_buttons.items():
            btn.setChecked(f == fmt)
        self.status_message.setText(f"Image format set to {fmt.upper()}")

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        if not USE_R:
            QMessageBox.information(self, "rpy2 unavailable", "rpy2 is not available in this Python environment.")
            return
        path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
        if not path:
            return
        try:
            robjects.r['source'](str(path))
            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']
            QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
            self.status_message.setText("R backend loaded")
        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R file:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

            # --- Breadcrumb / progress updates ---
            if not self.sample_paths:
                # No samples left: revert to baseline-only state
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # baseline = active
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            else:
                # Samples remain: highlight selection step
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(self.sample_paths)} sample(s) remaining â€” select one to preview")


    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        try:
                            self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                            self.progress_label.setText("Progress: preview generated (R)")
                        except Exception:
                            pass
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.progress_label.setText("Progress: preview generated (mock)")
            except Exception:
                pass

    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = getattr(self, "current_format", DEFAULT_IMAGE_EXT)

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()


mrg_backend.r:
# mrg_backend.R
# Minimal R backend for the MRG frontend.
# Exposes: preview_plot(baseline_path, sample_path, out_path)
#          batch_save_plots(baseline_path, sample_paths, out_dir, ext)

# ----- libraries -----
suppressMessages({
  library(tidyverse)
  library(stringr)
  library(ggpubr)
  library(cowplot)
})

# ----- helper: parse CSV -----
parseCSV <- function(csvFile = NULL){
  # read with header = TRUE and skip = 1 (as in your Rmd)
  # convert to numeric where possible
  df <- read.csv(csvFile, header = TRUE, sep = ",", stringsAsFactors = FALSE, skip = 1)
  # convert columns to numeric (coerce NAs)
  df[] <- lapply(df, function(col) as.numeric(as.character(col)))
  return(as.data.frame(df))
}

# ----- path-style plotting helper (keeps colors controllable) -----
ggplotDPath <- function(parsed = NULL, label = "Comparee"){
  geom_path(data = parsed,
            aes(x = cm.1, y = A, colour = label),
            show.legend = FALSE)
}

# ----- baseline setter (keeps baselinePlot and defaults in global env) -----
setBaseLine <- function(fileInputRaw=NULL){
  p <- parseCSV(fileInputRaw)
  defaultFileName <<- fileInputRaw
  defaultMin <<- min(p$A, na.rm = TRUE)
  defaultMax <<- max(p$A, na.rm = TRUE)

  baselinePlot <<- ggplot(p, aes(x = cm.1, y = A)) +
    theme_pubr() +
    theme(axis.text.x = element_text(size = 8), legend.title = element_blank()) +
    geom_path(aes(colour = defaultFileName), show.legend = TRUE) +
    scale_x_continuous(breaks = pretty(p$'cm.1', n = 20), trans = "reverse") +
    xlab("Wavelength (cmâ»Â¹)") +
    ylab("Amplitude (A)")

  invisible(baselinePlot)
}

# ----- add a sample graph onto baselinePlot -----
addGraph <- function(base = baselinePlot, fileInput=NULL){
  label <- fileInput
  cols <- c()
  cols[defaultFileName] <- "#008000"
  cols[label] <- "#0000FF"
  newGraph <- base + ggplotDPath(parseCSV(fileInput), label) +
    scale_colour_manual(values = cols, name = "Name:")
  return(newGraph)
}

# ----- convenience wrapper to return a single plot image for preview -----
preview_plot <- function(baseline_path, sample_path = "", out_path) {
  stopifnot(!is.null(baseline_path), file.exists(baseline_path))
  # set baseline globally (used by addGraph)
  setBaseLine(baseline_path)

  # produce plot
  if (!is.null(sample_path) && nzchar(sample_path) && file.exists(sample_path)) {
    g <- addGraph(baselinePlot, sample_path)
  } else {
    g <- baselinePlot
  }

  # ensure output dir exists and save
  out_dir <- dirname(out_path)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  ext <- tolower(tools::file_ext(out_path))
  # default to png if unknown
  if (ext == "") ext <- "png"

  ggsave(filename = basename(out_path),
         plot = g,
         device = ext,
         path = out_dir,
         dpi = 150,
         width = 6, height = 4, units = "in")
  invisible(TRUE)
}

# ----- batch saver for many sample files -----
batch_save_plots <- function(baseline_path, sample_paths, out_dir = getwd(), ext = "png") {
  stopifnot(!is.null(baseline_path), file.exists(baseline_path))
  setBaseLine(baseline_path)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

  for (s in sample_paths) {
    if (!file.exists(s)) {
      warning(paste("Skipping missing file:", s))
      next
    }
    g <- addGraph(baselinePlot, s)
    fname <- paste0(tools::file_path_sans_ext(baseline_path), "_vs_", tools::file_path_sans_ext(s), ".", ext)
    ggsave(filename = fname, plot = g, device = ext, path = out_dir, dpi = 320, width = 8, height = 5, units = "in")
  }
  invisible(TRUE)
}




Prompt 89 (Chat B):



yes




Prompt 90 (Chat B):



it still does not use the R scripts




Prompt 91 (Chat B):



1) after i replace it, i'm getting a message in the problems section of vscode:
"robjects" is not defined Pylance(reportUndefinedVariable) [Ln 306, Col 21]

here's the code block it's in:
        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

3: BatchSaveWorker.run(self) does not exist in main.py
4: it was already in the same folder
5: it printed the R version
6: have not tested




Prompt 92 (Chat B):



when i upload the baseline:
R preview failed: Error in geom_path(aes(colour =
defaultFileName), show.legend = TRUE) :
â†[1mâ†[22m
â†[36miâ†[39m Error occurred in the 1st layer.
â†[1mImCaused by error:â†[22m
â†[33m!â†[39m object 'cm.l' not found

The application will use a Python mock preview instead.




Prompt 93 (Chat B):



my teammate has provided me with the correct format for the csv files and the graphing works as intended. whenever i select graphs from the sample files section on the right, the graph gets longer horizontally, squishing the right side of the application, until it gets to a point where it stops squishing the right side and increases the horizontal length of the application and then the effect stops. whenever i manually resize the window by dragging the borders and then switch between graphs on the right side of the application a few times and then try to make the borders smaller, the borders wont go back to the original size when the application is opened.




Prompt 94 (Chat B):



after those replacements, attempting to load a .csv that worked before replacing the code blocks  opens a popup that says "R preview failed: name 'QSize' is not defined The application will use a Python mock preview instead." after pressing "OK", another popup says "Could not generate preview: name 'QSize' is not defined Please check your CSV files and try again."
here's my main.py **before** i've replaced those code blocks:


"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

#

try:
    import rpy2.robjects as robjects
except ImportError:
    robjects = None

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional) - more robust Windows-friendly detection
# -------------------------
USE_R = False
r_preview = None
r_batch = None

def _attempt_setup_rpy2(r_home_hint=r"C:\Program Files\R\R-4.5.2"):
    """
    Try to ensure R_HOME/PATH are present (Windows), import rpy2.robjects,
    and source a local mrg_backend.R if found. Returns (use_r, preview_fn, batch_fn, error_msg)
    """
    try:
        # If user hasn't set R_HOME, try a common default (change if your R is elsewhere)
        if "R_HOME" not in os.environ or not os.environ.get("R_HOME"):
            os.environ["R_HOME"] = r_home_hint

        # Ensure PATH contains R bin (so rpy2 can find libR)
        r_bin = os.path.join(os.environ["R_HOME"], "bin")
        if os.path.isdir(r_bin) and r_bin not in os.environ.get("PATH", ""):
            os.environ["PATH"] = r_bin + os.pathsep + os.environ.get("PATH", "")

        # Import rpy2 (may raise)
        import rpy2.robjects as robjects

        # If there is a project-local R backend, source it now so functions exist
        possible = Path(APP_ROOT) / "mrg_backend.R"
        if possible.exists():
            try:
                robjects.r['source'](str(possible))
                print(f"[Info] Sourced {possible}")
            except Exception as e:
                # continue, but warn
                print(f"[Warning] Could not source {possible}: {e}")

        g = robjects.globalenv
        preview_fn = g['preview_plot'] if 'preview_plot' in g else None
        batch_fn = g['batch_save_plots'] if 'batch_save_plots' in g else None

        use_r = bool(preview_fn or batch_fn)
        return use_r, preview_fn, batch_fn, None

    except Exception as e:
        return False, None, None, str(e)

_use_r, _r_preview, _r_batch, _r_err = _attempt_setup_rpy2()
if _use_r:
    USE_R = True
    r_preview = _r_preview
    r_batch = _r_batch
    print("[Info] rpy2 detected and R backend functions available.")
else:
    USE_R = False
    if _r_err:
        print("[Info] rpy2/R not ready:", _r_err)
    else:
        print("[Info] rpy2 imported but no backend functions found (mrg_backend.R not sourced).")
# -------------------------


# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)

        # MAIN CONTENT LAYOUTS
        # create the existing horizontal main layout (left / middle / right)
        main_layout = QHBoxLayout()

        # OUTER vertical layout holds breadcrumb nav on top and main_layout below
        outer_layout = QVBoxLayout()
        central.setLayout(outer_layout)

        # -----------------------
        # Breadcrumb / navigation bar (shows workflow stages)
        # -----------------------
        self.nav_stage1 = QLabel("â‘  Load Baseline")
        self.nav_stage2 = QLabel("â‘¡ Select Sample")
        self.nav_stage3 = QLabel("â‘¢ Generate Preview")

        for lbl in (self.nav_stage1, self.nav_stage2, self.nav_stage3):
            lbl.setStyleSheet(
                "font-weight: 600; color: #2b3a67; padding: 4px 8px; font-size: 12px;"
            )

        # small arrows between stages
        nav_bar = QHBoxLayout()
        nav_bar.addWidget(self.nav_stage1)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage2)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage3)
        nav_bar.addStretch()

        nav_widget = QWidget()
        nav_widget.setLayout(nav_bar)
        nav_widget.setStyleSheet("background-color: #eef2fa; border-radius: 6px; padding: 6px;")

        # add breadcrumb and the original main_layout into the outer layout
        outer_layout.addWidget(nav_widget)
        outer_layout.addLayout(main_layout)

        # simple progress label under the main layout (can be updated by actions)
        self.progress_label = QLabel("Progress: waiting for inputâ€¦")
        self.progress_label.setStyleSheet("color: #555; font-style: italic; padding-top:6px;")
        outer_layout.addWidget(self.progress_label)


        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        left.addWidget(QLabel("<b>Data Inputs</b>"))
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_samples)

        left.setSpacing(12)
        left.setContentsMargins(10, 10, 10, 10)

        # SECTION: Output Settings
        left.addSpacing(8)
        left.addWidget(QLabel("<b>Output Settings</b>"))
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_choose_out)

        # --- Image Format Selection (replaces dropdown) ---
        left.addWidget(QLabel("Select Image Format:"))

        format_button_layout = QHBoxLayout()
        self.format_buttons = {}

        def make_format_button(fmt):
            btn = QPushButton(fmt.upper())
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #e0e0e0;
                    border: 1px solid #ccc;
                    border-radius: 6px;
                    padding: 4px 10px;
                    font-weight: 600;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:checked {
                    background-color: #0078d7;
                    color: white;
                    border: 1px solid #005fa3;
                }
            """)
            btn.clicked.connect(lambda _, f=fmt: self.select_format(f))
            format_button_layout.addWidget(btn)
            self.format_buttons[fmt] = btn
        
        for fmt in SUPPORTED_EXTS:
            make_format_button(fmt)
        
        # Default selected format
        self.current_format = DEFAULT_IMAGE_EXT
        if self.current_format in self.format_buttons:
            self.format_buttons[self.current_format].setChecked(True)
        
        left.addLayout(format_button_layout)
        # --- End replacement ---


        # SECTION: Advanced (optional)
        left.addSpacing(6)
        left.addWidget(QLabel("<b>Advanced (optional)</b>"))
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        btn_load_r.setStyleSheet(
            "background-color: #17A2B8; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Preview display
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ccc; font-size: 16px; color: #111;"
        )
        self.preview_label.setMinimumHeight(300)
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)

        # Quick action
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        mid.addWidget(btn_preview_selected)

        # Small informative line under preview
        self.preview_status = QLabel("No preview yet")
        self.preview_status.setStyleSheet("color: #555; font-size: 12px;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        mid.addWidget(self.preview_status)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("<b>Sample Files</b>"))

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 13px; padding: 6px; border: 1px solid #ccc; background-color: #fefefe; color: #111;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_batch)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #333; font-size: 12px;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)


        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumWidth(200)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 13px; font-weight: bold; color: #111;"
        )
        self.statusBar().addPermanentWidget(self.status_message, 3)




    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active = green
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            except Exception:
                pass

            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)


    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(paths)} sample(s) loaded â€” select one to preview")
            except Exception:
                pass

            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)


    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def select_format(self, fmt):
        """Handle image format button selection and update the current format."""
        self.current_format = fmt
        for f, btn in self.format_buttons.items():
            btn.setChecked(f == fmt)
        self.status_message.setText(f"Image format set to {fmt.upper()}")

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        # This function will try to import rpy2 if it wasn't available at startup,
        # then source the chosen R file and pick up preview_plot / batch_save_plots.
        try:
            # If rpy2 wasn't importable at startup, try again now
            if not USE_R:
                # attempt the same setup function used at module import
                use_r, preview_fn, batch_fn, err = _attempt_setup_rpy2()
                if not use_r:
                    QMessageBox.critical(self, "rpy2 unavailable", f"rpy2 / R not available:\n{err or 'unknown error'}")
                    return
                # set globals from re-check
                globals()['USE_R'] = True
                globals()['r_preview'] = preview_fn
                globals()['r_batch'] = batch_fn

            # Prompt user for an R file to source (optional; user can still use project-local mrg_backend.R)
            path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
            if not path:
                return

            # source chosen file
            import rpy2.robjects as robjects
            try:
                robjects.r['source'](str(path))
            except Exception as e:
                QMessageBox.critical(self, "R load error", f"Could not source R file:\n{e}")
                return

            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']

            if not self.r_funcs.get('preview') and not self.r_funcs.get('batch'):
                QMessageBox.information(self, "R backend loaded", f"Sourced {Path(path).name} but preview/batch functions not found.")
            else:
                QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
                self.status_message.setText("R backend loaded")

        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R backend:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

            # --- Breadcrumb / progress updates ---
            if not self.sample_paths:
                # No samples left: revert to baseline-only state
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # baseline = active
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            else:
                # Samples remain: highlight selection step
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(self.sample_paths)} sample(s) remaining â€” select one to preview")


    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        try:
                            self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                            self.progress_label.setText("Progress: preview generated (R)")
                        except Exception:
                            pass
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.progress_label.setText("Progress: preview generated (mock)")
            except Exception:
                pass

    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = getattr(self, "current_format", DEFAULT_IMAGE_EXT)

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()




Prompt 95 (Chat B):



the bug is still the same, but instead of expanding and stopping whenever the graph is switched a certain amount of times, it expands and doesn't stop




Prompt 96 (Chat B):



use the anchor+end+replacement format




Prompt 97 (Chat B):



i meant lines of code as an anchor usually a comment, and lines of code as a way to indicate the end of a code block like what you did before




Prompt 98 (Chat C):



i have bug in my main.py, when i select different .csv files on the right panel on the application, the graph in the middle section elongates horizontally (a constant amount whenevery i switch .csv files). before it elongates, it seems compressed. after it elongates a certain amount of times, the window starts to elongate horizontally to a certain point, then starts to increase in size proportionally indefinitely. it is also supposed to use the r backend to graph, not the mock version.

main.py:


"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy, QScrollArea
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QSize

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

#

try:
    import rpy2.robjects as robjects
except ImportError:
    robjects = None

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional) - more robust Windows-friendly detection
# -------------------------
USE_R = False
r_preview = None
r_batch = None

def _attempt_setup_rpy2(r_home_hint=r"C:\Program Files\R\R-4.5.2"):
    """
    Try to ensure R_HOME/PATH are present (Windows), import rpy2.robjects,
    and source a local mrg_backend.R if found. Returns (use_r, preview_fn, batch_fn, error_msg)
    """
    try:
        # If user hasn't set R_HOME, try a common default (change if your R is elsewhere)
        if "R_HOME" not in os.environ or not os.environ.get("R_HOME"):
            os.environ["R_HOME"] = r_home_hint

        # Ensure PATH contains R bin (so rpy2 can find libR)
        r_bin = os.path.join(os.environ["R_HOME"], "bin")
        if os.path.isdir(r_bin) and r_bin not in os.environ.get("PATH", ""):
            os.environ["PATH"] = r_bin + os.pathsep + os.environ.get("PATH", "")

        # Import rpy2 (may raise)
        import rpy2.robjects as robjects

        # If there is a project-local R backend, source it now so functions exist
        possible = Path(APP_ROOT) / "mrg_backend.R"
        if possible.exists():
            try:
                robjects.r['source'](str(possible))
                print(f"[Info] Sourced {possible}")
            except Exception as e:
                # continue, but warn
                print(f"[Warning] Could not source {possible}: {e}")

        g = robjects.globalenv
        preview_fn = g['preview_plot'] if 'preview_plot' in g else None
        batch_fn = g['batch_save_plots'] if 'batch_save_plots' in g else None

        use_r = bool(preview_fn or batch_fn)
        return use_r, preview_fn, batch_fn, None

    except Exception as e:
        return False, None, None, str(e)

_use_r, _r_preview, _r_batch, _r_err = _attempt_setup_rpy2()
if _use_r:
    USE_R = True
    r_preview = _r_preview
    r_batch = _r_batch
    print("[Info] rpy2 detected and R backend functions available.")
else:
    USE_R = False
    if _r_err:
        print("[Info] rpy2/R not ready:", _r_err)
    else:
        print("[Info] rpy2 imported but no backend functions found (mrg_backend.R not sourced).")
# -------------------------


# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # --- Step 3 Fix: Use R backend safely ---
                try:
                    if self.r_funcs and isinstance(self.r_funcs, dict) and self.r_funcs.get('preview'):
                        # Call R preview function (pass empty string if sample_path is None)
                        self.r_funcs['preview'](self.baseline_path, sample_path or "", out_path)
                    else:
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                except Exception as e:
                    print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                    python_mock_preview(self.baseline_path, sample_path, out_path)
                # --- End Step 3 Fix ---


                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # --- Step 3 Fix: R Function Wrapper ---
        self.r_funcs = {}
        if USE_R:
            try:
                # If robjects wasn't imported earlier, try again dynamically
                if robjects is None:
                    try:
                        import rpy2.robjects as robjects
                    except Exception:
                        robjects = None
        
                if robjects is not None:
                    g = robjects.globalenv
                    if 'preview_plot' in g:
                        self.r_funcs['preview'] = g['preview_plot']
                    if 'batch_save_plots' in g:
                        self.r_funcs['batch'] = g['batch_save_plots']
            except Exception as e:
                print(f"[Warning] Couldn't initialize R functions: {e}")
                self.r_funcs = {}
        # --- End Step 3 Fix ---


        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)

        # MAIN CONTENT LAYOUTS
        # create the existing horizontal main layout (left / middle / right)
        main_layout = QHBoxLayout()

        # OUTER vertical layout holds breadcrumb nav on top and main_layout below
        outer_layout = QVBoxLayout()
        central.setLayout(outer_layout)

        # -----------------------
        # Breadcrumb / navigation bar (shows workflow stages)
        # -----------------------
        self.nav_stage1 = QLabel("â‘  Load Baseline")
        self.nav_stage2 = QLabel("â‘¡ Select Sample")
        self.nav_stage3 = QLabel("â‘¢ Generate Preview")

        for lbl in (self.nav_stage1, self.nav_stage2, self.nav_stage3):
            lbl.setStyleSheet(
                "font-weight: 600; color: #2b3a67; padding: 4px 8px; font-size: 12px;"
            )

        # small arrows between stages
        nav_bar = QHBoxLayout()
        nav_bar.addWidget(self.nav_stage1)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage2)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage3)
        nav_bar.addStretch()

        nav_widget = QWidget()
        nav_widget.setLayout(nav_bar)
        nav_widget.setStyleSheet("background-color: #eef2fa; border-radius: 6px; padding: 6px;")

        # add breadcrumb and the original main_layout into the outer layout
        outer_layout.addWidget(nav_widget)
        outer_layout.addLayout(main_layout)

        # simple progress label under the main layout (can be updated by actions)
        self.progress_label = QLabel("Progress: waiting for inputâ€¦")
        self.progress_label.setStyleSheet("color: #555; font-style: italic; padding-top:6px;")
        outer_layout.addWidget(self.progress_label)


        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        left.addWidget(QLabel("<b>Data Inputs</b>"))
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_samples)

        left.setSpacing(12)
        left.setContentsMargins(10, 10, 10, 10)

        # SECTION: Output Settings
        left.addSpacing(8)
        left.addWidget(QLabel("<b>Output Settings</b>"))
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_choose_out)

        # --- Image Format Selection (replaces dropdown) ---
        left.addWidget(QLabel("Select Image Format:"))

        format_button_layout = QHBoxLayout()
        self.format_buttons = {}

        def make_format_button(fmt):
            btn = QPushButton(fmt.upper())
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #e0e0e0;
                    border: 1px solid #ccc;
                    border-radius: 6px;
                    padding: 4px 10px;
                    font-weight: 600;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:checked {
                    background-color: #0078d7;
                    color: white;
                    border: 1px solid #005fa3;
                }
            """)
            btn.clicked.connect(lambda _, f=fmt: self.select_format(f))
            format_button_layout.addWidget(btn)
            self.format_buttons[fmt] = btn
        
        for fmt in SUPPORTED_EXTS:
            make_format_button(fmt)
        
        # Default selected format
        self.current_format = DEFAULT_IMAGE_EXT
        if self.current_format in self.format_buttons:
            self.format_buttons[self.current_format].setChecked(True)
        
        left.addLayout(format_button_layout)
        # --- End replacement ---


        # SECTION: Advanced (optional)
        left.addSpacing(6)
        left.addWidget(QLabel("<b>Advanced (optional)</b>"))
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        btn_load_r.setStyleSheet(
            "background-color: #17A2B8; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Preview display (stable sizing: prevents images from forcing window resize)
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ccc; font-size: 16px; color: #111;"
        )
        # Minimum height so layout looks stable, but no minimum width that would push layout horizontally
        self.preview_label.setMinimumHeight(300)
        
        # Make the label scale pixmaps to fit its geometry (pixmap won't change label size).
        self.preview_label.setScaledContents(True)
        
        # Keep it flexible in both directions so other widgets can shrink/grow predictably
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)



        # Quick action
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        mid.addWidget(btn_preview_selected)

        # Small informative line under preview
        self.preview_status = QLabel("No preview yet")
        self.preview_status.setStyleSheet("color: #555; font-size: 12px;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        mid.addWidget(self.preview_status)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("<b>Sample Files</b>"))

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 13px; padding: 6px; border: 1px solid #ccc; background-color: #fefefe; color: #111;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_batch)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #333; font-size: 12px;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)


        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumWidth(200)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 13px; font-weight: bold; color: #111;"
        )
        self.statusBar().addPermanentWidget(self.status_message, 3)




    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active = green
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            except Exception:
                pass

            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)


    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(paths)} sample(s) loaded â€” select one to preview")
            except Exception:
                pass

            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)


    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def select_format(self, fmt):
        """Handle image format button selection and update the current format."""
        self.current_format = fmt
        for f, btn in self.format_buttons.items():
            btn.setChecked(f == fmt)
        self.status_message.setText(f"Image format set to {fmt.upper()}")

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        # This function will try to import rpy2 if it wasn't available at startup,
        # then source the chosen R file and pick up preview_plot / batch_save_plots.
        try:
            # If rpy2 wasn't importable at startup, try again now
            if not USE_R:
                # attempt the same setup function used at module import
                use_r, preview_fn, batch_fn, err = _attempt_setup_rpy2()
                if not use_r:
                    QMessageBox.critical(self, "rpy2 unavailable", f"rpy2 / R not available:\n{err or 'unknown error'}")
                    return
                # set globals from re-check
                globals()['USE_R'] = True
                globals()['r_preview'] = preview_fn
                globals()['r_batch'] = batch_fn

            # Prompt user for an R file to source (optional; user can still use project-local mrg_backend.R)
            path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
            if not path:
                return

            # source chosen file
            import rpy2.robjects as robjects
            try:
                robjects.r['source'](str(path))
            except Exception as e:
                QMessageBox.critical(self, "R load error", f"Could not source R file:\n{e}")
                return

            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']

            if not self.r_funcs.get('preview') and not self.r_funcs.get('batch'):
                QMessageBox.information(self, "R backend loaded", f"Sourced {Path(path).name} but preview/batch functions not found.")
            else:
                QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
                self.status_message.setText("R backend loaded")

        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R backend:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

            # --- Breadcrumb / progress updates ---
            if not self.sample_paths:
                # No samples left: revert to baseline-only state
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # baseline = active
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            else:
                # Samples remain: highlight selection step
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(self.sample_paths)} sample(s) remaining â€” select one to preview")


    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        """
        Display the preview image while preventing the image from changing widget/layout size.
        Uses the preview_label's current size to scale the pixmap and removes accidental min/max constraints.
        """
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear any pixmap
            # ensure label doesn't hold an unwanted minimum/maximum
            self.preview_label.setMinimumSize(0, 0)
            self.preview_label.setMaximumSize(16777215, 16777215)
            return
    
        pix = QPixmap(path)
        if pix.isNull():
            self.preview_label.setText("Could not load preview image")
            self.preview_label.setPixmap(QPixmap())
            return
    
        # Use current label size as target so the pixmap won't expand the layout
        w = max(1, self.preview_label.width())
        h = max(1, self.preview_label.height())
        target_size = QSize(w, h)
    
        scaled = pix.scaled(target_size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)
        self.preview_label.setAlignment(Qt.AlignCenter)
    
        # Remove accidental persistent minimum/maximum sizes that could lock layout after manual resizes
        self.preview_label.setMinimumSize(0, 0)
        self.preview_label.setMaximumSize(16777215, 16777215)
    
        # Force a repaint/update
        self.preview_label.repaint()



    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        try:
                            self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                            self.progress_label.setText("Progress: preview generated (R)")
                        except Exception:
                            pass
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.progress_label.setText("Progress: preview generated (mock)")
            except Exception:
                pass

    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = getattr(self, "current_format", DEFAULT_IMAGE_EXT)

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()




mrg_backend.r:

# mrg_backend.R
# Minimal R backend for the MRG frontend.
# Exposes: preview_plot(baseline_path, sample_path, out_path)
#          batch_save_plots(baseline_path, sample_paths, out_dir, ext)

# ----- libraries -----
suppressMessages({
  library(tidyverse)
  library(stringr)
  library(ggpubr)
  library(cowplot)
})

# ----- helper: parse CSV -----
parseCSV <- function(csvFile = NULL){
  # read with header = TRUE and skip = 1 (as in your Rmd)
  # convert to numeric where possible
  df <- read.csv(csvFile, header = TRUE, sep = ",", stringsAsFactors = FALSE, skip = 1)
  # convert columns to numeric (coerce NAs)
  df[] <- lapply(df, function(col) as.numeric(as.character(col)))
  return(as.data.frame(df))
}

# ----- path-style plotting helper (keeps colors controllable) -----
ggplotDPath <- function(parsed = NULL, label = "Comparee"){
  geom_path(data = parsed,
            aes(x = cm.1, y = A, colour = label),
            show.legend = FALSE)
}

# ----- baseline setter (keeps baselinePlot and defaults in global env) -----
setBaseLine <- function(fileInputRaw=NULL){
  p <- parseCSV(fileInputRaw)
  defaultFileName <<- fileInputRaw
  defaultMin <<- min(p$A, na.rm = TRUE)
  defaultMax <<- max(p$A, na.rm = TRUE)

  baselinePlot <<- ggplot(p, aes(x = cm.1, y = A)) +
    theme_pubr() +
    theme(axis.text.x = element_text(size = 8), legend.title = element_blank()) +
    geom_path(aes(colour = defaultFileName), show.legend = TRUE) +
    scale_x_continuous(breaks = pretty(p$'cm.1', n = 20), trans = "reverse") +
    xlab("Wavelength (cmâ»Â¹)") +
    ylab("Amplitude (A)")

  invisible(baselinePlot)
}

# ----- add a sample graph onto baselinePlot -----
addGraph <- function(base = baselinePlot, fileInput=NULL){
  label <- fileInput
  cols <- c()
  cols[defaultFileName] <- "#008000"
  cols[label] <- "#0000FF"
  newGraph <- base + ggplotDPath(parseCSV(fileInput), label) +
    scale_colour_manual(values = cols, name = "Name:")
  return(newGraph)
}

# ----- convenience wrapper to return a single plot image for preview -----
preview_plot <- function(baseline_path, sample_path = "", out_path) {
  stopifnot(!is.null(baseline_path), file.exists(baseline_path))
  # set baseline globally (used by addGraph)
  setBaseLine(baseline_path)

  # produce plot
  if (!is.null(sample_path) && nzchar(sample_path) && file.exists(sample_path)) {
    g <- addGraph(baselinePlot, sample_path)
  } else {
    g <- baselinePlot
  }

  # ensure output dir exists and save
  out_dir <- dirname(out_path)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  ext <- tolower(tools::file_ext(out_path))
  # default to png if unknown
  if (ext == "") ext <- "png"

  ggsave(filename = basename(out_path),
         plot = g,
         device = ext,
         path = out_dir,
         dpi = 150,
         width = 6, height = 4, units = "in")
  invisible(TRUE)
}

# ----- batch saver for many sample files -----
batch_save_plots <- function(baseline_path, sample_paths, out_dir = getwd(), ext = "png") {
  stopifnot(!is.null(baseline_path), file.exists(baseline_path))
  setBaseLine(baseline_path)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

  for (s in sample_paths) {
    if (!file.exists(s)) {
      warning(paste("Skipping missing file:", s))
      next
    }
    g <- addGraph(baselinePlot, s)
    fname <- paste0(tools::file_path_sans_ext(baseline_path), "_vs_", tools::file_path_sans_ext(s), ".", ext)
    ggsave(filename = fname, plot = g, device = ext, path = out_dir, dpi = 320, width = 8, height = 5, units = "in")
  }
  invisible(TRUE)
}




Prompt 99 (Chat C):



step 2) i have this version where the graphing with r works, so i really don't think it's a problem with the R script:

"""
main_graphing_working_backup.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

#

try:
    import rpy2.robjects as robjects
except ImportError:
    robjects = None

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional) - more robust Windows-friendly detection
# -------------------------
USE_R = False
r_preview = None
r_batch = None

def _attempt_setup_rpy2(r_home_hint=r"C:\Program Files\R\R-4.5.2"):
    """
    Try to ensure R_HOME/PATH are present (Windows), import rpy2.robjects,
    and source a local mrg_backend.R if found. Returns (use_r, preview_fn, batch_fn, error_msg)
    """
    try:
        # If user hasn't set R_HOME, try a common default (change if your R is elsewhere)
        if "R_HOME" not in os.environ or not os.environ.get("R_HOME"):
            os.environ["R_HOME"] = r_home_hint

        # Ensure PATH contains R bin (so rpy2 can find libR)
        r_bin = os.path.join(os.environ["R_HOME"], "bin")
        if os.path.isdir(r_bin) and r_bin not in os.environ.get("PATH", ""):
            os.environ["PATH"] = r_bin + os.pathsep + os.environ.get("PATH", "")

        # Import rpy2 (may raise)
        import rpy2.robjects as robjects

        # If there is a project-local R backend, source it now so functions exist
        possible = Path(APP_ROOT) / "mrg_backend.R"
        if possible.exists():
            try:
                robjects.r['source'](str(possible))
                print(f"[Info] Sourced {possible}")
            except Exception as e:
                # continue, but warn
                print(f"[Warning] Could not source {possible}: {e}")

        g = robjects.globalenv
        preview_fn = g['preview_plot'] if 'preview_plot' in g else None
        batch_fn = g['batch_save_plots'] if 'batch_save_plots' in g else None

        use_r = bool(preview_fn or batch_fn)
        return use_r, preview_fn, batch_fn, None

    except Exception as e:
        return False, None, None, str(e)

_use_r, _r_preview, _r_batch, _r_err = _attempt_setup_rpy2()
if _use_r:
    USE_R = True
    r_preview = _r_preview
    r_batch = _r_batch
    print("[Info] rpy2 detected and R backend functions available.")
else:
    USE_R = False
    if _r_err:
        print("[Info] rpy2/R not ready:", _r_err)
    else:
        print("[Info] rpy2 imported but no backend functions found (mrg_backend.R not sourced).")
# -------------------------


# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)

        # MAIN CONTENT LAYOUTS
        # create the existing horizontal main layout (left / middle / right)
        main_layout = QHBoxLayout()

        # OUTER vertical layout holds breadcrumb nav on top and main_layout below
        outer_layout = QVBoxLayout()
        central.setLayout(outer_layout)

        # -----------------------
        # Breadcrumb / navigation bar (shows workflow stages)
        # -----------------------
        self.nav_stage1 = QLabel("â‘  Load Baseline")
        self.nav_stage2 = QLabel("â‘¡ Select Sample")
        self.nav_stage3 = QLabel("â‘¢ Generate Preview")

        for lbl in (self.nav_stage1, self.nav_stage2, self.nav_stage3):
            lbl.setStyleSheet(
                "font-weight: 600; color: #2b3a67; padding: 4px 8px; font-size: 12px;"
            )

        # small arrows between stages
        nav_bar = QHBoxLayout()
        nav_bar.addWidget(self.nav_stage1)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage2)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage3)
        nav_bar.addStretch()

        nav_widget = QWidget()
        nav_widget.setLayout(nav_bar)
        nav_widget.setStyleSheet("background-color: #eef2fa; border-radius: 6px; padding: 6px;")

        # add breadcrumb and the original main_layout into the outer layout
        outer_layout.addWidget(nav_widget)
        outer_layout.addLayout(main_layout)

        # simple progress label under the main layout (can be updated by actions)
        self.progress_label = QLabel("Progress: waiting for inputâ€¦")
        self.progress_label.setStyleSheet("color: #555; font-style: italic; padding-top:6px;")
        outer_layout.addWidget(self.progress_label)


        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        left.addWidget(QLabel("<b>Data Inputs</b>"))
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_samples)

        left.setSpacing(12)
        left.setContentsMargins(10, 10, 10, 10)

        # SECTION: Output Settings
        left.addSpacing(8)
        left.addWidget(QLabel("<b>Output Settings</b>"))
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_choose_out)

        # --- Image Format Selection (replaces dropdown) ---
        left.addWidget(QLabel("Select Image Format:"))

        format_button_layout = QHBoxLayout()
        self.format_buttons = {}

        def make_format_button(fmt):
            btn = QPushButton(fmt.upper())
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #e0e0e0;
                    border: 1px solid #ccc;
                    border-radius: 6px;
                    padding: 4px 10px;
                    font-weight: 600;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:checked {
                    background-color: #0078d7;
                    color: white;
                    border: 1px solid #005fa3;
                }
            """)
            btn.clicked.connect(lambda _, f=fmt: self.select_format(f))
            format_button_layout.addWidget(btn)
            self.format_buttons[fmt] = btn
        
        for fmt in SUPPORTED_EXTS:
            make_format_button(fmt)
        
        # Default selected format
        self.current_format = DEFAULT_IMAGE_EXT
        if self.current_format in self.format_buttons:
            self.format_buttons[self.current_format].setChecked(True)
        
        left.addLayout(format_button_layout)
        # --- End replacement ---


        # SECTION: Advanced (optional)
        left.addSpacing(6)
        left.addWidget(QLabel("<b>Advanced (optional)</b>"))
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        btn_load_r.setStyleSheet(
            "background-color: #17A2B8; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Preview display
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ccc; font-size: 16px; color: #111;"
        )
        self.preview_label.setMinimumHeight(300)
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)

        # Quick action
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        mid.addWidget(btn_preview_selected)

        # Small informative line under preview
        self.preview_status = QLabel("No preview yet")
        self.preview_status.setStyleSheet("color: #555; font-size: 12px;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        mid.addWidget(self.preview_status)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("<b>Sample Files</b>"))

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 13px; padding: 6px; border: 1px solid #ccc; background-color: #fefefe; color: #111;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_batch)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #333; font-size: 12px;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)


        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumWidth(200)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 13px; font-weight: bold; color: #111;"
        )
        self.statusBar().addPermanentWidget(self.status_message, 3)




    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active = green
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            except Exception:
                pass

            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)


    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(paths)} sample(s) loaded â€” select one to preview")
            except Exception:
                pass

            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)


    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def select_format(self, fmt):
        """Handle image format button selection and update the current format."""
        self.current_format = fmt
        for f, btn in self.format_buttons.items():
            btn.setChecked(f == fmt)
        self.status_message.setText(f"Image format set to {fmt.upper()}")

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        # This function will try to import rpy2 if it wasn't available at startup,
        # then source the chosen R file and pick up preview_plot / batch_save_plots.
        try:
            # If rpy2 wasn't importable at startup, try again now
            if not USE_R:
                # attempt the same setup function used at module import
                use_r, preview_fn, batch_fn, err = _attempt_setup_rpy2()
                if not use_r:
                    QMessageBox.critical(self, "rpy2 unavailable", f"rpy2 / R not available:\n{err or 'unknown error'}")
                    return
                # set globals from re-check
                globals()['USE_R'] = True
                globals()['r_preview'] = preview_fn
                globals()['r_batch'] = batch_fn

            # Prompt user for an R file to source (optional; user can still use project-local mrg_backend.R)
            path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
            if not path:
                return

            # source chosen file
            import rpy2.robjects as robjects
            try:
                robjects.r['source'](str(path))
            except Exception as e:
                QMessageBox.critical(self, "R load error", f"Could not source R file:\n{e}")
                return

            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']

            if not self.r_funcs.get('preview') and not self.r_funcs.get('batch'):
                QMessageBox.information(self, "R backend loaded", f"Sourced {Path(path).name} but preview/batch functions not found.")
            else:
                QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
                self.status_message.setText("R backend loaded")

        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R backend:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

            # --- Breadcrumb / progress updates ---
            if not self.sample_paths:
                # No samples left: revert to baseline-only state
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # baseline = active
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            else:
                # Samples remain: highlight selection step
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(self.sample_paths)} sample(s) remaining â€” select one to preview")


    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        try:
                            self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                            self.progress_label.setText("Progress: preview generated (R)")
                        except Exception:
                            pass
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.progress_label.setText("Progress: preview generated (mock)")
            except Exception:
                pass

    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = getattr(self, "current_format", DEFAULT_IMAGE_EXT)

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()




Prompt 100 (Chat C):



im using vscode. both problems persist.
Terminal:

PS C:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025> & C:/Python314/python.exe "c:/Users/yfedd/Downloads/hackathon/YCP Hacks 2025/main.py"
'sh' is not recognized as an internal or external command,
operable program or batch file.
Error importing in API mode: ImportError('On Windows, cffi mode "ANY" is only "ABI".')
Trying to import in ABI mode.
APP_ROOT    = c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025
DEFAULT_SAVE_DIR = c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\schneider_output
TEMP_DIR    = c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\schneider_output\temp_previews
cwd         = c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025
[Info] Sourced c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\mrg_backend.R
[Info] rpy2 detected and R backend functions available.
[Warning] Couldn't initialize R functions: cannot access local variable 'robjects' where it is not associated with a value
[Debug] preview file c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\schneider_output\temp_previews\preview__880 Crown & Chassis_91685__baseline.png pixel size: 600x400
[Debug] preview file c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\schneider_output\temp_previews\preview__880 Crown & Chassis_91685__28229.png pixel size: 600x400
[Debug] preview file c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\schneider_output\temp_previews\preview__880 Crown & Chassis_91685__28227.png pixel size: 600x400
[Debug] preview file c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\schneider_output\temp_previews\preview__880 Crown & Chassis_91685__25945.png pixel size: 600x400
[Debug] preview file c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\schneider_output\temp_previews\preview__880 Crown & Chassis_91685__24252.png pixel size: 600x400
[Debug] preview file c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\schneider_output\temp_previews\preview__880 Crown & Chassis_91685__19231.png pixel size: 600x400
[Debug] preview file c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\schneider_output\temp_previews\preview__880 Crown & Chassis_91685__28226.png pixel size: 600x400
[Debug] preview file c:\Users\yfedd\Downloads\hackathon\YCP Hacks 2025\schneider_output\temp_previews\preview__880 Crown & Chassis_91685__28228.png pixel size: 600x400


Output:

Error: the task 'R: Install Package' neither specifies a command nor a dependsOn property. The task will be ignored. Its definition is:
{
    "type": "process",
    "id": "process,C:\\Program Files\\R\\R-4.5.2\\bin\\R.exe,--silent,--no-echo,--no-save,--no-restore,-e,install.packages('languageserver',, repos='https://cran.r-project.org/'),",
    "problemMatcher": [],
    "label": "R: Install Package"
}




Prompt 101 (Chat D):



can you fix the legend on the graph so that it doesn't show the full file path
main.py:


"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

#

try:
    import rpy2.robjects as robjects
except ImportError:
    robjects = None

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional) - more robust Windows-friendly detection
# -------------------------
USE_R = False
r_preview = None
r_batch = None

def _attempt_setup_rpy2(r_home_hint=r"C:\Program Files\R\R-4.5.2"):
    """
    Try to ensure R_HOME/PATH are present (Windows), import rpy2.robjects,
    and source a local mrg_backend.R if found. Returns (use_r, preview_fn, batch_fn, error_msg)
    """
    try:
        # If user hasn't set R_HOME, try a common default (change if your R is elsewhere)
        if "R_HOME" not in os.environ or not os.environ.get("R_HOME"):
            os.environ["R_HOME"] = r_home_hint

        # Ensure PATH contains R bin (so rpy2 can find libR)
        r_bin = os.path.join(os.environ["R_HOME"], "bin")
        if os.path.isdir(r_bin) and r_bin not in os.environ.get("PATH", ""):
            os.environ["PATH"] = r_bin + os.pathsep + os.environ.get("PATH", "")

        # Import rpy2 (may raise)
        import rpy2.robjects as robjects

        # If there is a project-local R backend, source it now so functions exist
        possible = Path(APP_ROOT) / "mrg_backend.R"
        if possible.exists():
            try:
                robjects.r['source'](str(possible))
                print(f"[Info] Sourced {possible}")
            except Exception as e:
                # continue, but warn
                print(f"[Warning] Could not source {possible}: {e}")

        g = robjects.globalenv
        preview_fn = g['preview_plot'] if 'preview_plot' in g else None
        batch_fn = g['batch_save_plots'] if 'batch_save_plots' in g else None

        use_r = bool(preview_fn or batch_fn)
        return use_r, preview_fn, batch_fn, None

    except Exception as e:
        return False, None, None, str(e)

_use_r, _r_preview, _r_batch, _r_err = _attempt_setup_rpy2()
if _use_r:
    USE_R = True
    r_preview = _r_preview
    r_batch = _r_batch
    print("[Info] rpy2 detected and R backend functions available.")
else:
    USE_R = False
    if _r_err:
        print("[Info] rpy2/R not ready:", _r_err)
    else:
        print("[Info] rpy2 imported but no backend functions found (mrg_backend.R not sourced).")
# -------------------------


# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)

        # MAIN CONTENT LAYOUTS
        # create the existing horizontal main layout (left / middle / right)
        main_layout = QHBoxLayout()

        # OUTER vertical layout holds breadcrumb nav on top and main_layout below
        outer_layout = QVBoxLayout()
        central.setLayout(outer_layout)

        # -----------------------
        # Breadcrumb / navigation bar (shows workflow stages)
        # -----------------------
        self.nav_stage1 = QLabel("â‘  Load Baseline")
        self.nav_stage2 = QLabel("â‘¡ Select Sample")
        self.nav_stage3 = QLabel("â‘¢ Generate Preview")

        for lbl in (self.nav_stage1, self.nav_stage2, self.nav_stage3):
            lbl.setStyleSheet(
                "font-weight: 600; color: #2b3a67; padding: 4px 8px; font-size: 12px;"
            )

        # small arrows between stages
        nav_bar = QHBoxLayout()
        nav_bar.addWidget(self.nav_stage1)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage2)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage3)
        nav_bar.addStretch()

        nav_widget = QWidget()
        nav_widget.setLayout(nav_bar)
        nav_widget.setStyleSheet("background-color: #eef2fa; border-radius: 6px; padding: 6px;")

        # add breadcrumb and the original main_layout into the outer layout
        outer_layout.addWidget(nav_widget)
        outer_layout.addLayout(main_layout)

        # simple progress label under the main layout (can be updated by actions)
        self.progress_label = QLabel("Progress: waiting for inputâ€¦")
        self.progress_label.setStyleSheet("color: #555; font-style: italic; padding-top:6px;")
        outer_layout.addWidget(self.progress_label)


        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        left.addWidget(QLabel("<b>Data Inputs</b>"))
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_samples)

        left.setSpacing(12)
        left.setContentsMargins(10, 10, 10, 10)

        # SECTION: Output Settings
        left.addSpacing(8)
        left.addWidget(QLabel("<b>Output Settings</b>"))
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_choose_out)

        # --- Image Format Selection (replaces dropdown) ---
        left.addWidget(QLabel("Select Image Format:"))

        format_button_layout = QHBoxLayout()
        self.format_buttons = {}

        def make_format_button(fmt):
            btn = QPushButton(fmt.upper())
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #e0e0e0;
                    border: 1px solid #ccc;
                    border-radius: 6px;
                    padding: 4px 10px;
                    font-weight: 600;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:checked {
                    background-color: #0078d7;
                    color: white;
                    border: 1px solid #005fa3;
                }
            """)
            btn.clicked.connect(lambda _, f=fmt: self.select_format(f))
            format_button_layout.addWidget(btn)
            self.format_buttons[fmt] = btn
        
        for fmt in SUPPORTED_EXTS:
            make_format_button(fmt)
        
        # Default selected format
        self.current_format = DEFAULT_IMAGE_EXT
        if self.current_format in self.format_buttons:
            self.format_buttons[self.current_format].setChecked(True)
        
        left.addLayout(format_button_layout)
        # --- End replacement ---


        # SECTION: Advanced (optional)
        left.addSpacing(6)
        left.addWidget(QLabel("<b>Advanced (optional)</b>"))
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        btn_load_r.setStyleSheet(
            "background-color: #17A2B8; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Preview display
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ccc; font-size: 16px; color: #111;"
        )
        self.preview_label.setMinimumHeight(300)
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)

        # Quick action
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        mid.addWidget(btn_preview_selected)

        # Small informative line under preview
        self.preview_status = QLabel("No preview yet")
        self.preview_status.setStyleSheet("color: #555; font-size: 12px;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        mid.addWidget(self.preview_status)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("<b>Sample Files</b>"))

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 13px; padding: 6px; border: 1px solid #ccc; background-color: #fefefe; color: #111;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_batch)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #333; font-size: 12px;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)


        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumWidth(200)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 13px; font-weight: bold; color: #111;"
        )
        self.statusBar().addPermanentWidget(self.status_message, 3)




    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active = green
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            except Exception:
                pass

            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)


    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(paths)} sample(s) loaded â€” select one to preview")
            except Exception:
                pass

            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)


    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def select_format(self, fmt):
        """Handle image format button selection and update the current format."""
        self.current_format = fmt
        for f, btn in self.format_buttons.items():
            btn.setChecked(f == fmt)
        self.status_message.setText(f"Image format set to {fmt.upper()}")

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        # This function will try to import rpy2 if it wasn't available at startup,
        # then source the chosen R file and pick up preview_plot / batch_save_plots.
        try:
            # If rpy2 wasn't importable at startup, try again now
            if not USE_R:
                # attempt the same setup function used at module import
                use_r, preview_fn, batch_fn, err = _attempt_setup_rpy2()
                if not use_r:
                    QMessageBox.critical(self, "rpy2 unavailable", f"rpy2 / R not available:\n{err or 'unknown error'}")
                    return
                # set globals from re-check
                globals()['USE_R'] = True
                globals()['r_preview'] = preview_fn
                globals()['r_batch'] = batch_fn

            # Prompt user for an R file to source (optional; user can still use project-local mrg_backend.R)
            path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
            if not path:
                return

            # source chosen file
            import rpy2.robjects as robjects
            try:
                robjects.r['source'](str(path))
            except Exception as e:
                QMessageBox.critical(self, "R load error", f"Could not source R file:\n{e}")
                return

            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']

            if not self.r_funcs.get('preview') and not self.r_funcs.get('batch'):
                QMessageBox.information(self, "R backend loaded", f"Sourced {Path(path).name} but preview/batch functions not found.")
            else:
                QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
                self.status_message.setText("R backend loaded")

        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R backend:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

            # --- Breadcrumb / progress updates ---
            if not self.sample_paths:
                # No samples left: revert to baseline-only state
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # baseline = active
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            else:
                # Samples remain: highlight selection step
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(self.sample_paths)} sample(s) remaining â€” select one to preview")


    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        try:
                            self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                            self.progress_label.setText("Progress: preview generated (R)")
                        except Exception:
                            pass
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.progress_label.setText("Progress: preview generated (mock)")
            except Exception:
                pass

    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = getattr(self, "current_format", DEFAULT_IMAGE_EXT)

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()



mrg_backend.r:


# mrg_backend.R
# Minimal R backend for the MRG frontend.
# Exposes: preview_plot(baseline_path, sample_path, out_path)
#          batch_save_plots(baseline_path, sample_paths, out_dir, ext)

# ----- libraries -----
suppressMessages({
  library(tidyverse)
  library(stringr)
  library(ggpubr)
  library(cowplot)
})

# ----- helper: parse CSV -----
parseCSV <- function(csvFile = NULL){
  # read with header = TRUE and skip = 1 (as in your Rmd)
  # convert to numeric where possible
  df <- read.csv(csvFile, header = TRUE, sep = ",", stringsAsFactors = FALSE, skip = 1)
  # convert columns to numeric (coerce NAs)
  df[] <- lapply(df, function(col) as.numeric(as.character(col)))
  return(as.data.frame(df))
}

# ----- path-style plotting helper (keeps colors controllable) -----
ggplotDPath <- function(parsed = NULL, label = "Comparee"){
  geom_path(data = parsed,
            aes(x = cm.1, y = A, colour = label),
            show.legend = FALSE)
}

# ----- baseline setter (keeps baselinePlot and defaults in global env) -----
setBaseLine <- function(fileInputRaw=NULL){
  p <- parseCSV(fileInputRaw)
  defaultFileName <<- fileInputRaw
  defaultMin <<- min(p$A, na.rm = TRUE)
  defaultMax <<- max(p$A, na.rm = TRUE)

  baselinePlot <<- ggplot(p, aes(x = cm.1, y = A)) +
    theme_pubr() +
    theme(axis.text.x = element_text(size = 8), legend.title = element_blank()) +
    geom_path(aes(colour = defaultFileName), show.legend = TRUE) +
    scale_x_continuous(breaks = pretty(p$'cm.1', n = 20), trans = "reverse") +
    xlab("Wavelength (cmâ»Â¹)") +
    ylab("Amplitude (A)")

  invisible(baselinePlot)
}

# ----- add a sample graph onto baselinePlot -----
addGraph <- function(base = baselinePlot, fileInput=NULL){
  label <- fileInput
  cols <- c()
  cols[defaultFileName] <- "#008000"
  cols[label] <- "#0000FF"
  newGraph <- base + ggplotDPath(parseCSV(fileInput), label) +
    scale_colour_manual(values = cols, name = "Name:")
  return(newGraph)
}

# ----- convenience wrapper to return a single plot image for preview -----
preview_plot <- function(baseline_path, sample_path = "", out_path) {
  stopifnot(!is.null(baseline_path), file.exists(baseline_path))
  # set baseline globally (used by addGraph)
  setBaseLine(baseline_path)

  # produce plot
  if (!is.null(sample_path) && nzchar(sample_path) && file.exists(sample_path)) {
    g <- addGraph(baselinePlot, sample_path)
  } else {
    g <- baselinePlot
  }

  # ensure output dir exists and save
  out_dir <- dirname(out_path)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
  ext <- tolower(tools::file_ext(out_path))
  # default to png if unknown
  if (ext == "") ext <- "png"

  ggsave(filename = basename(out_path),
         plot = g,
         device = ext,
         path = out_dir,
         dpi = 150,
         width = 6, height = 4, units = "in")
  invisible(TRUE)
}

# ----- batch saver for many sample files -----
batch_save_plots <- function(baseline_path, sample_paths, out_dir = getwd(), ext = "png") {
  stopifnot(!is.null(baseline_path), file.exists(baseline_path))
  setBaseLine(baseline_path)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

  for (s in sample_paths) {
    if (!file.exists(s)) {
      warning(paste("Skipping missing file:", s))
      next
    }
    g <- addGraph(baselinePlot, s)
    fname <- paste0(tools::file_path_sans_ext(baseline_path), "_vs_", tools::file_path_sans_ext(s), ".", ext)
    ggsave(filename = fname, plot = g, device = ext, path = out_dir, dpi = 320, width = 8, height = 5, units = "in")
  }
  invisible(TRUE)
}




Prompt 102 (Chat D):



it works, can you now fix the label on the bottom of the graph




Prompt 103 (Chat D):



rename the x axis as: wavelength cm-1




Prompt 104 (Chat D):



not found




Prompt 105 (Chat D):



the x axis label is not fixed




Prompt 106 (Chat D):



the python script uses r to graph




Prompt 107 (Chat D):



tell me which parts of the code to replace with existing lines of code as references for the start and end of what should be replaced




Prompt 108 (Chat D):



add 2 space indents to each line




Prompt 109 (Chat D):



could not find function ggplotdpath




Prompt 110 (Chat D):



retype the code for the entire file




Prompt 111 (Chat D):



can you make the y axis increments 0.5 




Prompt 112 (Chat D):



add this to the file




Prompt 113 (Chat E):



there's a bug in the main.py code. it accesses backend r functions that i have not pasted here. when i select different .csv files on the right panel on the application, the graph in the middle section increases in length horizontally (a constant amount whenever i switch .csv files). after it elongates a certain amount of times due to .csv file selection, the window starts to elongate by itself horizontally to a certain point, then stops. i want you to plan and write out how you will fix this bug, what tests you'll run, etc.


"""
main.py - MRG Labs sponsored hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy
)
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtCore import Qt, QThread, pyqtSignal

import pandas as pd

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

#

try:
    import rpy2.robjects as robjects
except ImportError:
    robjects = None

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional) - more robust Windows-friendly detection
# -------------------------
USE_R = False
r_preview = None
r_batch = None

def _attempt_setup_rpy2(r_home_hint=r"C:\Program Files\R\R-4.5.2"):
    """
    Try to ensure R_HOME/PATH are present (Windows), import rpy2.robjects,
    and source a local mrg_backend.R if found. Returns (use_r, preview_fn, batch_fn, error_msg)
    """
    try:
        # If user hasn't set R_HOME, try a common default (change if your R is elsewhere)
        if "R_HOME" not in os.environ or not os.environ.get("R_HOME"):
            os.environ["R_HOME"] = r_home_hint

        # Ensure PATH contains R bin (so rpy2 can find libR)
        r_bin = os.path.join(os.environ["R_HOME"], "bin")
        if os.path.isdir(r_bin) and r_bin not in os.environ.get("PATH", ""):
            os.environ["PATH"] = r_bin + os.pathsep + os.environ.get("PATH", "")

        # Import rpy2 (may raise)
        import rpy2.robjects as robjects

        # If there is a project-local R backend, source it now so functions exist
        possible = Path(APP_ROOT) / "mrg_backend.R"
        if possible.exists():
            try:
                robjects.r['source'](str(possible))
                print(f"[Info] Sourced {possible}")
            except Exception as e:
                # continue, but warn
                print(f"[Warning] Could not source {possible}: {e}")

        g = robjects.globalenv
        preview_fn = g['preview_plot'] if 'preview_plot' in g else None
        batch_fn = g['batch_save_plots'] if 'batch_save_plots' in g else None

        use_r = bool(preview_fn or batch_fn)
        return use_r, preview_fn, batch_fn, None

    except Exception as e:
        return False, None, None, str(e)

_use_r, _r_preview, _r_batch, _r_err = _attempt_setup_rpy2()
if _use_r:
    USE_R = True
    r_preview = _r_preview
    r_batch = _r_batch
    print("[Info] rpy2 detected and R backend functions available.")
else:
    USE_R = False
    if _r_err:
        print("[Info] rpy2/R not ready:", _r_err)
    else:
        print("[Info] rpy2 imported but no backend functions found (mrg_backend.R not sourced).")
# -------------------------


# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


    plt.figure(figsize=(6, 4))
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        plt.plot(bx, by, color='green', label=Path(baseline_csv).name)
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    plt.legend()
    plt.title("Preview (mock)")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.tight_layout()

    try:
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        print(f"[Info] Preview saved to {out_path}")
    except Exception as e:
        print(f"[Error] Could not save preview to {out_path}: {e}")
    finally:
        plt.close()

    return out_path
# -------------------------



# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs Frontend")
        self.resize(1100, 700)

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)

        # MAIN CONTENT LAYOUTS
        # create the existing horizontal main layout (left / middle / right)
        main_layout = QHBoxLayout()

        # OUTER vertical layout holds breadcrumb nav on top and main_layout below
        outer_layout = QVBoxLayout()
        central.setLayout(outer_layout)

        # -----------------------
        # Breadcrumb / navigation bar (shows workflow stages)
        # -----------------------
        self.nav_stage1 = QLabel("â‘  Load Baseline")
        self.nav_stage2 = QLabel("â‘¡ Select Sample")
        self.nav_stage3 = QLabel("â‘¢ Generate Preview")

        for lbl in (self.nav_stage1, self.nav_stage2, self.nav_stage3):
            lbl.setStyleSheet(
                "font-weight: 600; color: #2b3a67; padding: 4px 8px; font-size: 12px;"
            )

        # small arrows between stages
        nav_bar = QHBoxLayout()
        nav_bar.addWidget(self.nav_stage1)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage2)
        nav_bar.addWidget(QLabel("â†’"))
        nav_bar.addWidget(self.nav_stage3)
        nav_bar.addStretch()

        nav_widget = QWidget()
        nav_widget.setLayout(nav_bar)
        nav_widget.setStyleSheet("background-color: #eef2fa; border-radius: 6px; padding: 6px;")

        # add breadcrumb and the original main_layout into the outer layout
        outer_layout.addWidget(nav_widget)
        outer_layout.addLayout(main_layout)

        # simple progress label under the main layout (can be updated by actions)
        self.progress_label = QLabel("Progress: waiting for inputâ€¦")
        self.progress_label.setStyleSheet("color: #555; font-style: italic; padding-top:6px;")
        outer_layout.addWidget(self.progress_label)


        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        left.addWidget(QLabel("<b>Data Inputs</b>"))
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs (multi)")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 14px;"
            "border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_samples)

        left.setSpacing(12)
        left.setContentsMargins(10, 10, 10, 10)

        # SECTION: Output Settings
        left.addSpacing(8)
        left.addWidget(QLabel("<b>Output Settings</b>"))
        left.addWidget(QLabel("Output folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose output folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_choose_out)

        # --- Image Format Selection (replaces dropdown) ---
        left.addWidget(QLabel("Select Image Format:"))

        format_button_layout = QHBoxLayout()
        self.format_buttons = {}

        def make_format_button(fmt):
            btn = QPushButton(fmt.upper())
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #e0e0e0;
                    border: 1px solid #ccc;
                    border-radius: 6px;
                    padding: 4px 10px;
                    font-weight: 600;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:checked {
                    background-color: #0078d7;
                    color: white;
                    border: 1px solid #005fa3;
                }
            """)
            btn.clicked.connect(lambda _, f=fmt: self.select_format(f))
            format_button_layout.addWidget(btn)
            self.format_buttons[fmt] = btn
        
        for fmt in SUPPORTED_EXTS:
            make_format_button(fmt)
        
        # Default selected format
        self.current_format = DEFAULT_IMAGE_EXT
        if self.current_format in self.format_buttons:
            self.format_buttons[self.current_format].setChecked(True)
        
        left.addLayout(format_button_layout)
        # --- End replacement ---


        # SECTION: Advanced (optional)
        left.addSpacing(6)
        left.addWidget(QLabel("<b>Advanced (optional)</b>"))
        btn_load_r = QPushButton("Load R backend (optional)")
        btn_load_r.setToolTip("Load an R script for previews if rpy2 is installed.")
        btn_load_r.clicked.connect(self.load_r_backend)
        btn_load_r.setStyleSheet(
            "background-color: #17A2B8; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        left.addWidget(btn_load_r)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Preview display
        self.preview_label = QLabel("Preview area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ccc; font-size: 16px; color: #111;"
        )
        self.preview_label.setMinimumHeight(300)
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)

        # Quick action
        btn_preview_selected = QPushButton("Preview selected sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        mid.addWidget(btn_preview_selected)

        # Small informative line under preview
        self.preview_status = QLabel("No preview yet")
        self.preview_status.setStyleSheet("color: #555; font-size: 12px;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        mid.addWidget(self.preview_status)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        right.addWidget(QLabel("<b>Sample Files</b>"))

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 13px; padding: 6px; border: 1px solid #ccc; background-color: #fefefe; color: #111;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove selected sample")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch save all graphs")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 5px; padding: 6px;"
        )
        right.addWidget(btn_batch)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #333; font-size: 12px;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)


        # Bottom: status/progress
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumWidth(200)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        self.statusBar().addPermanentWidget(self.progress, 1)

        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 13px; font-weight: bold; color: #111;"
        )
        self.statusBar().addPermanentWidget(self.status_message, 3)




    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline loaded: {Path(path).name}")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active = green
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            except Exception:
                pass

            # auto-generate a preview for baseline-only
            self.generate_and_show_preview(None)


    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} sample(s) loaded")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # active
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(paths)} sample(s) loaded â€” select one to preview")
            except Exception:
                pass

            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)


    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose output directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output dir: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def select_format(self, fmt):
        """Handle image format button selection and update the current format."""
        self.current_format = fmt
        for f, btn in self.format_buttons.items():
            btn.setChecked(f == fmt)
        self.status_message.setText(f"Image format set to {fmt.upper()}")

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        # This function will try to import rpy2 if it wasn't available at startup,
        # then source the chosen R file and pick up preview_plot / batch_save_plots.
        try:
            # If rpy2 wasn't importable at startup, try again now
            if not USE_R:
                # attempt the same setup function used at module import
                use_r, preview_fn, batch_fn, err = _attempt_setup_rpy2()
                if not use_r:
                    QMessageBox.critical(self, "rpy2 unavailable", f"rpy2 / R not available:\n{err or 'unknown error'}")
                    return
                # set globals from re-check
                globals()['USE_R'] = True
                globals()['r_preview'] = preview_fn
                globals()['r_batch'] = batch_fn

            # Prompt user for an R file to source (optional; user can still use project-local mrg_backend.R)
            path, _ = QFileDialog.getOpenFileName(self, "Select R backend file", str(Path.cwd()), "R Files (*.R *.r)")
            if not path:
                return

            # source chosen file
            import rpy2.robjects as robjects
            try:
                robjects.r['source'](str(path))
            except Exception as e:
                QMessageBox.critical(self, "R load error", f"Could not source R file:\n{e}")
                return

            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']

            if not self.r_funcs.get('preview') and not self.r_funcs.get('batch'):
                QMessageBox.information(self, "R backend loaded", f"Sourced {Path(path).name} but preview/batch functions not found.")
            else:
                QMessageBox.information(self, "R backend loaded", f"Loaded {Path(path).name}")
                self.status_message.setText("R backend loaded")

        except Exception as e:
            QMessageBox.critical(self, "R load error", f"Could not load R backend:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed sample: {Path(removed).name}")

            # --- Breadcrumb / progress updates ---
            if not self.sample_paths:
                # No samples left: revert to baseline-only state
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")  # baseline = active
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText("Progress: baseline loaded â€” select sample(s)")
            else:
                # Samples remain: highlight selection step
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.progress_label.setText(f"Progress: {len(self.sample_paths)} sample(s) remaining â€” select one to preview")


    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No selection", "Please select a sample to preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No preview available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def resizeEvent(self, event):
        # rescale preview when window resizes
        super().resizeEvent(event)
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)




    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", 
                                "Please load a baseline CSV first. "
                                "The preview cannot be generated without it.")
            self.status_message.setText("No baseline loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview loaded from cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview loaded from cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview generated using R backend")
                        try:
                            self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                            self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                            self.progress_label.setText("Progress: preview generated (R)")
                        except Exception:
                            pass
                        return
                except Exception as e:
                    msg = (f"R preview failed: {str(e)}\n"
                           "The application will use a Python mock preview instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview generated using Python mock (synthetic)")
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 4px 8px;")
                self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 4px 8px;")
                self.progress_label.setText("Progress: preview generated (mock)")
            except Exception:
                pass

    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could not generate preview:\n{str(e)}\n\n"
                       "Please check your CSV files and try again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview generation failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing baseline", "Please load a baseline CSV first.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing samples", "Please load sample CSVs first.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = getattr(self, "current_format", DEFAULT_IMAGE_EXT)

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could not create output folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch save started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} files to:\n{self.batch_worker.out_dir}")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()




Prompt 114 (Chat E):



try to identify "why" in your potential issues and other contributing factors sections




Prompt 115 (Chat E):



now that we know why these bugs happen, what should we do next




Prompt 116 (Chat E):



is it possible use the setMaximumWidth and setMaximumHeight to constrain the maximum height and width of the graph area by using math with numbers relative to the window size instead of proportions while having the same effect as constraining it using proportions




Prompt 117 (Chat E):



since resizing the window before clicking the .csv files after it is uploaded also triggers the increase, i think we should increase the minimum value to minimum size of the window after it resizes horizontally




Prompt 118 (Chat E):



self.preview_label.setMinimumWidth(self.width() * 0.5)  # example: half of current window width
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
TypeError: setMinimumWidth(self, minw: int): argument 1 has unexpected type 'float'




Prompt 119 (Chat E):



shouldn't we be changing something like set minimum width




Prompt 120 (Chat E):



shouldn't we be changing the code in this section:
class MainWindow(QMainWindow):
    def __init__(self):




Prompt 121 (Chat E):



i want to set that in the first render
