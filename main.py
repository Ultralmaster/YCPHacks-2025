"""
main.py - MRG Labs Sponsored Hack Frontend

Features:
- Load one baseline CSV (overwrites previous)
- Load multiple sample CSVs (overwrites previous set)
- Auto-preview: selecting a sample automatically regenerates/loads a preview
- Preview uses R backend (via rpy2) if available, otherwise a Python mock generator (matplotlib)
- Batch save all plots in background thread (keeps UI responsive)
- Progress bar and status messages
- Easy top-of-file configuration (DEFAULT_SAVE_DIR, DEFAULT_IMAGE_EXT)
- No external 'mocks' or 'assets' folders required
- Enhanced UI with progress dialogs, results formatting, and export functionality
- PDF export with analysis and graph
- Dynamic UI scaling based on window size
"""

import sys
import os
import traceback
from pathlib import Path
from functools import partial
from datetime import datetime

import base64
import requests
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QFileDialog, QLabel, QPushButton,
    QHBoxLayout, QVBoxLayout, QListWidget, QComboBox, QProgressBar, QMessageBox,
    QLineEdit, QAction, QToolBar, QSizePolicy, QTextEdit, QProgressDialog, QScrollArea,
    QFrame
)
from PyQt5.QtGui import QPixmap, QIcon, QFont, QColor
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer, QSize

import pandas as pd

# Try to import reportlab for PDF generation
try:
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, PageBreak
    from reportlab.lib import colors
    HAS_REPORTLAB = True
except ImportError:
    HAS_REPORTLAB = False

# --- Ensure all paths are absolute and based on main.py's location ---
import os
from pathlib import Path

try:
    import rpy2.robjects as robjects
except ImportError:
    robjects = None

# Base directory where main.py lives (guaranteed)
APP_ROOT = os.path.dirname(os.path.abspath(__file__))

# Ensure the process CWD is APP_ROOT (optional, but makes behavior consistent)
# Comment out if you intentionally want a different working dir elsewhere.
os.chdir(APP_ROOT)

# Use absolute project-local output dirs (no accidental saves above project)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Per-preview temp filename pattern (we'll write distinct files inside TEMP_DIR)
# (do not hardcode any relative paths anywhere else)
# Example preview filenames will be generated by generate_preview_path() below.
# ensure directories exist at startup
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Debug output so you can confirm locations in the terminal
print(f"APP_ROOT    = {APP_ROOT}")
print(f"DEFAULT_SAVE_DIR = {DEFAULT_SAVE_DIR}")
print(f"TEMP_DIR    = {TEMP_DIR}")
print(f"cwd         = {os.getcwd()}")


# -------------------------
# Top-level parameters (easy to change)
# -------------------------
DEFAULT_IMAGE_EXT = "png"  # 'png' or 'jpg'
SUPPORTED_EXTS = ["png", "jpg"]

# Keep all output inside the project folder (APP_ROOT)
DEFAULT_SAVE_DIR = str(Path(APP_ROOT) / "schneider_output")
TEMP_DIR = str(Path(DEFAULT_SAVE_DIR) / "temp_previews")

# Ensure the temp and output folders exist
os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)
# -------------------------


# -------------------------
# Attempt rpy2 integration (optional) - more robust Windows-friendly detection
# -------------------------
USE_R = False
r_preview = None
r_batch = None

def _attempt_setup_rpy2(r_home_hint=r"C:\Program Files\R\R-4.5.2"):
    """
    Try to ensure R_HOME/PATH are present (Windows), import rpy2.robjects,
    and source a local mrg_backend.R if found. Returns (use_r, preview_fn, batch_fn, error_msg)
    """
    try:
        # If user hasn't set R_HOME, try a common default (change if your R is elsewhere)
        if "R_HOME" not in os.environ or not os.environ.get("R_HOME"):
            os.environ["R_HOME"] = r_home_hint

        # Ensure PATH contains R bin (so rpy2 can find libR)
        r_bin = os.path.join(os.environ["R_HOME"], "bin")
        if os.path.isdir(r_bin) and r_bin not in os.environ.get("PATH", ""):
            os.environ["PATH"] = r_bin + os.pathsep + os.environ.get("PATH", "")

        # Import rpy2 (may raise)
        import rpy2.robjects as robjects

        # If there is a project-local R backend, source it now so functions exist
        possible = Path(APP_ROOT) / "mrg_backend.R"
        if possible.exists():
            try:
                robjects.r['source'](str(possible))
                print(f"[Info] Sourced {possible}")
            except Exception as e:
                # continue, but warn
                print(f"[Warning] Could not source {possible}: {e}")

        g = robjects.globalenv
        preview_fn = g['preview_plot'] if 'preview_plot' in g else None
        batch_fn = g['batch_save_plots'] if 'batch_save_plots' in g else None

        use_r = bool(preview_fn or batch_fn)
        return use_r, preview_fn, batch_fn, None

    except Exception as e:
        return False, None, None, str(e)

_use_r, _r_preview, _r_batch, _r_err = _attempt_setup_rpy2()
if _use_r:
    USE_R = True
    r_preview = _r_preview
    r_batch = _r_batch
    print("[Info] rpy2 detected and R backend functions available.")
else:
    USE_R = False
    if _r_err:
        print("[Info] rpy2/R not ready:", _r_err)
    else:
        print("[Info] rpy2 imported but no backend functions found (mrg_backend.R not sourced).")
# -------------------------


# -------------------------
# Python mock preview generator (matplotlib) - used when R isn't available
# -------------------------
def python_mock_preview(baseline_csv, sample_csv, out_path):
    """
    Create a simple preview using matplotlib so GUI can show something.
    baseline_csv or sample_csv may be None or empty string (baseline-only acceptable).
    Reports any malformed CSVs in a single message.
    """
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import numpy as np

    malformed_files = []

    def read_first_numeric(path):
        try:
            df = pd.read_csv(path, header=None)
            numeric_df = df.apply(pd.to_numeric, errors='coerce')
            numeric_df = numeric_df.dropna(how='all')
            if numeric_df.empty:
                raise ValueError("No numeric data found")
            x = numeric_df.iloc[:, 0].values
            y = numeric_df.iloc[:, 1].values if numeric_df.shape[1] > 1 else np.zeros_like(x)
            return x, y
        except Exception as e:
            # Collect the file in the malformed list
            malformed_files.append((path, str(e)))
            # Return None to skip plotting this file
            return None, None

    plt.figure(figsize=(6,4))

    # Plot baseline
    if baseline_csv:
        bx, by = read_first_numeric(baseline_csv)
        if bx is not None:
            plt.plot(bx, by, color='green', label=Path(baseline_csv).name)

    # Plot sample
    if sample_csv:
        sx, sy = read_first_numeric(sample_csv)
        if sx is not None:
            plt.plot(sx, sy, color='blue', label=Path(sample_csv).name)

    # Show legend only if at least one valid line
    if plt.gca().has_data():
        plt.legend()
        plt.title("Preview (mock)")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.tight_layout()
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        plt.savefig(out_path)
        plt.close()
    else:
        # No valid data to plot
        out_path = None

    # Show all errors in a single message
    if malformed_files:
        msg = "The following CSV files could not be parsed:\n\n"
        for f, err in malformed_files:
            msg += f"- {Path(f).name}: {err}\n"
        from PyQt5.QtWidgets import QMessageBox
        QMessageBox.critical(None, "CSV Parsing Errors", msg)

    return out_path


# -------------------------


# -------------------------
# QThread worker for batch save (keeps GUI responsive)
# -------------------------
class BatchSaveWorker(QThread):
    progress = pyqtSignal(int)
    finished = pyqtSignal(list, str)
    error = pyqtSignal(str)

    def __init__(self, baseline_path, sample_paths, out_dir, ext, r_funcs=None):
        super().__init__()
        self.baseline_path = baseline_path
        self.sample_paths = sample_paths
        self.out_dir = out_dir
        self.ext = ext
        self.r_funcs = r_funcs  # <--- store the R functions or None

    def run(self):
        try:
            paths = []
            total = len(self.sample_paths)
            for i, sample_path in enumerate(self.sample_paths, start=1):
                base = os.path.splitext(os.path.basename(sample_path))[0]
                out_path = os.path.join(self.out_dir, f"{base}_preview.{self.ext}")

                # Create directory if missing
                os.makedirs(os.path.dirname(out_path), exist_ok=True)

                # Use R backend if available, else mock fallback
                if self.r_funcs and hasattr(self.r_funcs, "generate_preview"):
                    try:
                        self.r_funcs.generate_preview(self.baseline_path, sample_path, out_path)
                    except Exception as e:
                        print(f"[Warning] R backend failed: {e}\nFalling back to Python mock preview.")
                        python_mock_preview(self.baseline_path, sample_path, out_path)
                else:
                    python_mock_preview(self.baseline_path, sample_path, out_path)

                paths.append(out_path)
                progress = int((i / total) * 100)
                self.progress.emit(progress)

            msg = f"Batch processing complete ({len(paths)} files)"
            self.finished.emit(paths, msg)

        except Exception as e:
            self.error.emit(str(e))

# -------------------------

# -------------------------
# Main Window
# -------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MRG Labs FTIR Analysis Frontend")
        self.resize(1200, 750)
        
        # Set window icon from SchneiderNRMSubmissions.ico if it exists
        icon_path = os.path.join(APP_ROOT, "SchneiderNRMSubmissions.ico")
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))

        # State
        self.baseline_path = None
        self.sample_paths = []
        self.output_dir = DEFAULT_SAVE_DIR
        self.image_ext = DEFAULT_IMAGE_EXT
        self.showing_graph = True  # Track whether we're showing graph or text box
        self.ai_analysis_texts = {}  # Store AI analysis text for each sample
        
        # Gemini API key
        self.gemini_api_key = self.read_gemini_key()

        # Preview cache: sample_path -> preview_image_path
        self._preview_cache = {}

        # r functions wrapper
        self.r_funcs = {}
        if USE_R:
            try:
                g = robjects.globalenv
                if 'preview_plot' in g:
                    self.r_funcs['preview'] = g['preview_plot']
                if 'batch_save_plots' in g:
                    self.r_funcs['batch'] = g['batch_save_plots']
            except Exception:
                pass

        # UI wiring
        central = QWidget()
        self.setCentralWidget(central)

        # MAIN CONTENT LAYOUTS
        # create the existing horizontal main layout (left / middle / right)
        main_layout = QHBoxLayout()

        # OUTER vertical layout holds breadcrumb nav on top and main_layout below
        outer_layout = QVBoxLayout()
        central.setLayout(outer_layout)

        # -----------------------
        # Breadcrumb / navigation bar (shows workflow stages)
        # -----------------------
        self.nav_stage1 = QLabel("1. Load Baseline")
        self.nav_stage2 = QLabel("2. Select Sample")
        self.nav_stage3 = QLabel("3. Generate Preview")
        self.nav_stage4 = QLabel("4. Analyze With AI")

        # Initialize breadcrumb styling - stage 1 active by default
        self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 18px 28px; font-size: 16px;")  # active = green
        for lbl in (self.nav_stage2, self.nav_stage3, self.nav_stage4):
            lbl.setStyleSheet(
                "font-weight: 600; color: #2b3a67; padding: 18px 28px; font-size: 16px;"
            )

        # larger arrows between stages
        nav_bar = QHBoxLayout()
        nav_bar.addWidget(self.nav_stage1)
        nav_bar.addWidget(QLabel("→"), 0, Qt.AlignCenter)
        nav_bar.addWidget(self.nav_stage2)
        nav_bar.addWidget(QLabel("→"), 0, Qt.AlignCenter)
        nav_bar.addWidget(self.nav_stage3)
        nav_bar.addWidget(QLabel("→"), 0, Qt.AlignCenter)
        nav_bar.addWidget(self.nav_stage4)
        nav_bar.addStretch()

        nav_widget = QWidget()
        nav_widget.setLayout(nav_bar)
        nav_widget.setStyleSheet("background-color: #eef2fa; border-radius: 15px; padding: 20px;")

        # add breadcrumb and the original main_layout into the outer layout
        outer_layout.addWidget(nav_widget)
        outer_layout.addLayout(main_layout)


        # --- Left: controls (inputs) ---
        left = QVBoxLayout()

        # SECTION: Data Inputs
        section_title = QLabel("Data Inputs")
        section_title.setFont(QFont("Arial", 12, QFont.Bold))
        section_title.setStyleSheet("color: #2b3a67; padding: 9px 0px;")
        left.addWidget(section_title)
        
        btn_load_base = QPushButton("Load Baseline CSV")
        btn_load_base.setToolTip("Select one baseline CSV file to load (overwrites previous baseline).")
        btn_load_base.clicked.connect(self.load_baseline)
        btn_load_base.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 13px;"
            "border-radius: 8px; padding: 11px; border: none;"
        )
        left.addWidget(btn_load_base)

        btn_load_samples = QPushButton("Load Sample CSVs")
        btn_load_samples.setToolTip("Select one or more sample CSV files to compare with baseline.")
        btn_load_samples.clicked.connect(self.load_samples)
        btn_load_samples.setStyleSheet(
            "background-color: #007BFF; color: white; font-weight: bold; font-size: 13px;"
            "border-radius: 8px; padding: 11px; border: none;"
        )
        left.addWidget(btn_load_samples)

        left.addSpacing(15)
        left.addWidget(QFrame())  # Separator

        # SECTION: Output Settings
        section_title2 = QLabel("Output Settings")
        section_title2.setFont(QFont("Arial", 12, QFont.Bold))
        section_title2.setStyleSheet("color: #2b3a67; padding: 9px 0px;")
        left.addWidget(section_title2)
        
        left.addWidget(QLabel("Output Folder:"))
        self.out_edit = QLineEdit(self.output_dir)
        self.out_edit.setReadOnly(True)
        self.out_edit.setToolTip("Output folder for saved previews")
        self.out_edit.setStyleSheet("background-color: #f9f9f9; color: #222; border-radius: 5px; padding: 8px;")
        left.addWidget(self.out_edit)

        btn_choose_out = QPushButton("Choose Output Folder")
        btn_choose_out.setToolTip("Select a folder where preview images will be saved.")
        btn_choose_out.clicked.connect(self.choose_output_dir)
        btn_choose_out.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 8px; padding: 9px; border: none; font-size: 13px;"
        )
        left.addWidget(btn_choose_out)

        # --- Image Format Selection ---
        left.addWidget(QLabel("Image Format:"))

        format_button_layout = QHBoxLayout()
        self.format_buttons = {}

        def make_format_button(fmt):
            btn = QPushButton(fmt.upper())
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #e0e0e0;
                    border: 1px solid #ccc;
                    border-radius: 6px;
                    padding: 7px 13px;
                    font-weight: 600;
                    font-size: 12px;
                }
                QPushButton:hover {
                    background-color: #f5f5f5;
                }
                QPushButton:checked {
                    background-color: #0078d7;
                    color: white;
                    border: 1px solid #005fa3;
                }
            """)
            btn.clicked.connect(lambda _, f=fmt: self.select_format(f))
            format_button_layout.addWidget(btn)
            self.format_buttons[fmt] = btn
        
        for fmt in SUPPORTED_EXTS:
            make_format_button(fmt)
        
        # Default selected format
        self.current_format = DEFAULT_IMAGE_EXT
        if self.current_format in self.format_buttons:
            self.format_buttons[self.current_format].setChecked(True)
        
        left.addLayout(format_button_layout)

        left.addStretch()
        main_layout.addLayout(left, 1)

        # --- Middle: preview area ---
        mid = QVBoxLayout()

        # Top row: Preview/Analysis title and Show Analysis button
        top_row = QHBoxLayout()
        top_row.addStretch()
        self.toggle_button = QPushButton("Show Analysis")
        self.toggle_button.setToolTip("Toggle between graph view and AI analysis text box")
        self.toggle_button.clicked.connect(self.toggle_view)
        self.toggle_button.setStyleSheet(
            "background-color: #6c757d; color: white; font-weight: bold; border-radius: 5px; padding: 6px; border: none; font-size: 11px;"
        )
        top_row.addWidget(self.toggle_button)
        mid.addLayout(top_row)

        # Preview display
        self.preview_label = QLabel("Preview Area")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ddd; font-size: 15px; color: #999; border-radius: 8px;"
        )
        self.preview_label.setMinimumHeight(300)
        self.preview_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.preview_label.setToolTip(
            "This area displays the preview of baseline and sample data.\n"
            "Load a baseline first, then select a sample to preview."
        )
        mid.addWidget(self.preview_label, 8)

        # AI Analysis Text Box (initially hidden)
        self.ai_analysis_box = QTextEdit()
        self.ai_analysis_box.setPlaceholderText("AI Analysis Results Will Appear Here...")
        self.ai_analysis_box.setStyleSheet(
            "background-color: #ffffff; border: 2px solid #ddd; font-size: 12px; color: #333; border-radius: 8px; padding: 9px;"
        )
        self.ai_analysis_box.setMinimumHeight(300)
        self.ai_analysis_box.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.ai_analysis_box.setReadOnly(False)
        self.ai_analysis_box.hide()  # Initially hidden
        mid.addWidget(self.ai_analysis_box, 8)

        # Action buttons (hidden by default, shown only when needed)
        action_layout = QHBoxLayout()
        
        btn_preview_selected = QPushButton("Preview Selected Sample")
        btn_preview_selected.setToolTip("Generate a preview for the currently selected sample CSV.")
        btn_preview_selected.clicked.connect(self.preview_selected_sample)
        btn_preview_selected.setStyleSheet(
            "background-color: #FFC107; color: #111; font-weight: bold; border-radius: 6px; padding: 7px; border: none; font-size: 12px;"
        )
        btn_preview_selected.hide()  # Hidden by default
        self.btn_preview_selected = btn_preview_selected
        action_layout.addWidget(btn_preview_selected)

        btn_copy_analysis = QPushButton("Copy Analysis")
        btn_copy_analysis.setToolTip("Copy analysis results to clipboard")
        btn_copy_analysis.clicked.connect(self.copy_analysis_to_clipboard)
        btn_copy_analysis.setStyleSheet(
            "background-color: #17a2b8; color: white; font-weight: bold; border-radius: 6px; padding: 7px; border: none; font-size: 12px;"
        )
        btn_copy_analysis.hide()
        self.btn_copy_analysis = btn_copy_analysis
        action_layout.addWidget(btn_copy_analysis)

        btn_save_analysis = QPushButton("Save Analysis As PDF")
        btn_save_analysis.setToolTip("Save analysis results and graph to a PDF file")
        btn_save_analysis.clicked.connect(self.save_analysis_to_pdf)
        btn_save_analysis.setStyleSheet(
            "background-color: #6c757d; color: white; font-weight: bold; border-radius: 6px; padding: 7px; border: none; font-size: 12px;"
        )
        btn_save_analysis.hide()
        self.btn_save_analysis = btn_save_analysis
        action_layout.addWidget(btn_save_analysis)

        mid.addLayout(action_layout)

        # Progress bar at bottom
        progress_layout = QHBoxLayout()
        self.progress = QProgressBar()
        self.progress.setValue(0)
        self.progress.setMinimumHeight(25)
        self.progress.setStyleSheet(
            "QProgressBar {border: 1px solid #aaa; border-radius: 5px; text-align: center; font-weight: bold;}"
            "QProgressBar::chunk {background-color: #28A745; width: 20px;}"
        )
        progress_layout.addWidget(self.progress)

        # Small informative line
        self.preview_status = QLabel("No Preview Yet")
        self.preview_status.setStyleSheet("color: #888; font-size: 11px; font-style: italic;")
        self.preview_status.setAlignment(Qt.AlignCenter)
        progress_layout.addWidget(self.preview_status)

        mid.addLayout(progress_layout)

        main_layout.addLayout(mid, 3)


        # --- Right: sample list + actions ---
        right = QVBoxLayout()
        
        section_title3 = QLabel("Sample Files")
        section_title3.setFont(QFont("Arial", 12, QFont.Bold))
        section_title3.setStyleSheet("color: #2b3a67; padding: 9px 0px;")
        right.addWidget(section_title3)

        # Sample list (styled for readability)
        self.sample_list = QListWidget()
        self.sample_list.setStyleSheet(
            "font-size: 12px; padding: 6px; border: 1px solid #ddd; background-color: #fefefe; color: #111; border-radius: 6px;"
        )
        self.sample_list.currentRowChanged.connect(self.on_sample_selected)
        right.addWidget(self.sample_list, 6)

        # Actions
        btn_remove = QPushButton("Remove Selected")
        btn_remove.setToolTip("Remove the currently selected sample from the list.")
        btn_remove.clicked.connect(self.remove_selected_sample)
        btn_remove.setStyleSheet(
            "background-color: #DC3545; color: white; font-weight: bold; border-radius: 6px; padding: 7px; border: none; font-size: 12px;"
        )
        right.addWidget(btn_remove)

        btn_batch = QPushButton("Batch Save All")
        btn_batch.setToolTip("Save previews for all loaded samples to the output folder.")
        btn_batch.clicked.connect(self.batch_save)
        btn_batch.setStyleSheet(
            "background-color: #28A745; color: white; font-weight: bold; border-radius: 6px; padding: 7px; border: none; font-size: 12px;"
        )
        right.addWidget(btn_batch)

        btn_analyze = QPushButton("Send To Gemini")
        btn_analyze.setToolTip("Send current preview, baseline, and sample to Gemini for FTIR spectroscopy analysis")
        btn_analyze.clicked.connect(self.send_current_to_gemini)
        btn_analyze.setStyleSheet(
            "background-color: #9c27b0; color: white; font-weight: bold; border-radius: 6px; padding: 7px; border: none; font-size: 12px;"
        )
        right.addWidget(btn_analyze)

        # Batch / status info
        self.batch_status = QLabel("Ready")
        self.batch_status.setStyleSheet("color: #666; font-size: 11px; text-align: center;")
        self.batch_status.setAlignment(Qt.AlignCenter)
        right.addWidget(self.batch_status)

        main_layout.addLayout(right, 1)

        # Add large status message below main layout
        self.status_message = QLabel("Ready")
        self.status_message.setStyleSheet(
            "font-size: 16px; font-weight: bold; color: #2b3a67; padding: 12px; background-color: #f0f0f0; border-radius: 5px;"
        )
        self.status_message.setAlignment(Qt.AlignCenter)
        outer_layout.addWidget(self.status_message)

        # Apply initial scaling
        self.update_ui_scale()

    def get_scale_factor(self):
        """Calculate scale factor based on window size"""
        width = self.width()
        height = self.height()
        # Base scale at 1200x750
        base_width = 1200
        base_height = 750
        scale = min(width / base_width, height / base_height)
        # Clamp between 0.7 and 1.5
        return max(0.7, min(1.5, scale))

    def update_ui_scale(self):
        """Update all UI elements based on current window size"""
        scale = self.get_scale_factor()
        
        # Scale navigation labels
        nav_font_size = int(16 * scale)
        nav_padding = int(18 * scale)
        for lbl in (self.nav_stage1, self.nav_stage2, self.nav_stage3, self.nav_stage4):
            lbl.setStyleSheet(
                f"font-weight: 800; color: #2b3a67; padding: {nav_padding}px {nav_padding}px; font-size: {nav_font_size}px;"
            )
        
        # Scale section titles (Data Inputs, Output Settings, Sample Files)
        section_font_size = int(12 * scale)
        section_padding = int(9 * scale)
        for lbl in self.findChildren(QLabel):
            # Check if this is a section title by looking for bold font and specific text
            if lbl.font().bold() and lbl.text() in ["Data Inputs", "Output Settings", "Sample Files"]:
                lbl.setStyleSheet(f"color: #2b3a67; padding: {section_padding}px 0px; font-size: {section_font_size}px; font-weight: bold;")
        
        # Scale sample list font size (much larger for better visibility)
        sample_list_font_size = int(16 * scale)
        sample_list_padding = int(12 * scale)
        sample_list_item_height = int(30 * scale)
        sample_list_style = f"QListWidget {{ font-size: {sample_list_font_size}px; padding: {sample_list_padding}px; border: 1px solid #ddd; background-color: #fefefe; color: #111; border-radius: 6px; }} QListWidget::item {{ padding: {sample_list_padding}px; height: {sample_list_item_height}px; }}"
        self.sample_list.setStyleSheet(sample_list_style)
        
        # Scale buttons with dynamic stylesheet updates
        button_font_size = int(13 * scale)
        button_padding = int(11 * scale)
        button_min_height = int(37 * scale)
        for btn in self.findChildren(QPushButton):
            # Update font size via stylesheet
            current_style = btn.styleSheet()
            # Replace font-size in stylesheet
            import re
            updated_style = re.sub(r'font-size:\s*\d+px', f'font-size: {button_font_size}px', current_style)
            updated_style = re.sub(r'padding:\s*\d+px', f'padding: {button_padding}px', updated_style)
            btn.setStyleSheet(updated_style)
            btn.setMinimumHeight(button_min_height)
        
        # Scale text edit
        text_font_size = int(12 * scale)
        text_font = self.ai_analysis_box.font()
        text_font.setPointSize(text_font_size)
        self.ai_analysis_box.setFont(text_font)
        
        # Scale preview label
        preview_font_size = int(15 * scale)
        preview_font = self.preview_label.font()
        preview_font.setPointSize(preview_font_size)
        self.preview_label.setFont(preview_font)
        
        # Scale status bar elements
        status_font_size = int(12 * scale)
        status_font = self.status_message.font()
        status_font.setPointSize(status_font_size)
        self.status_message.setFont(status_font)

    def resizeEvent(self, event):
        """Handle window resize events"""
        super().resizeEvent(event)
        self.update_ui_scale()
        
        # Rescale preview when window resizes
        if hasattr(self, '_last_preview_size') and self._last_preview_size == self.preview_label.size():
            return
            
        self._last_preview_size = self.preview_label.size()
        
        cur = self.sample_list.currentRow()
        preview_path = None
        if cur >= 0 and cur < len(self.sample_paths):
            s = self.sample_paths[cur]
            preview_path = self._preview_cache.get(s)
        else:
            preview_path = self._preview_cache.get('__baseline__')
        if preview_path and os.path.exists(preview_path):
            self.show_image_in_preview(preview_path)

    def toggle_view(self):
        """Toggle between graph view and AI analysis text box"""
        # Get current sample path
        current_sample_path = None
        current_row = self.sample_list.currentRow()
        if 0 <= current_row < len(self.sample_paths):
            current_sample_path = self.sample_paths[current_row]
        
        if self.showing_graph:
            # Save current text before switching
            if current_sample_path:
                self.ai_analysis_texts[current_sample_path] = self.ai_analysis_box.toPlainText()
            
            # Switch to text box view
            self.preview_label.hide()
            self.ai_analysis_box.show()
            self.toggle_button.setText("Show Graph")
            self.showing_graph = False
            self.btn_copy_analysis.show()
            self.btn_save_analysis.show()
            
            # Load AI analysis text for current sample
            if current_sample_path:
                text = self.ai_analysis_texts.get(current_sample_path, "")
                self.ai_analysis_box.setPlainText(text)
        else:
            # Save current text before switching
            if current_sample_path:
                self.ai_analysis_texts[current_sample_path] = self.ai_analysis_box.toPlainText()
            
            # Switch to graph view
            self.ai_analysis_box.hide()
            self.preview_label.show()
            self.toggle_button.setText("Show Analysis")
            self.showing_graph = True
            self.btn_copy_analysis.hide()
            self.btn_save_analysis.hide()

    def copy_analysis_to_clipboard(self):
        """Copy analysis text to clipboard"""
        import subprocess
        text = self.ai_analysis_box.toPlainText()
        if text:
            try:
                # Use Windows clipboard
                process = subprocess.Popen(['clip'], stdin=subprocess.PIPE)
                process.communicate(text.encode('utf-8'))
                QMessageBox.information(self, "Success", "Analysis Copied To Clipboard!")
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Could Not Copy To Clipboard: {e}")
        else:
            QMessageBox.warning(self, "Empty", "No Analysis To Copy.")

    def save_analysis_to_pdf(self):
        """Save analysis results and graph to a PDF file"""
        if not HAS_REPORTLAB:
            QMessageBox.warning(self, "Missing Dependency", 
                "ReportLab Is Not Installed. Please Install It With:\npip install reportlab")
            return
        
        cur_row = self.sample_list.currentRow()
        if cur_row < 0:
            QMessageBox.warning(self, "No Selection", "Please Select A Sample First.")
            return
        
        sample_name = Path(self.sample_paths[cur_row]).stem
        default_filename = f"FTIR_Analysis_{sample_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
        
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Analysis As PDF", 
            os.path.join(self.output_dir, default_filename),
            "PDF Files (*.pdf);;All Files (*)"
        )
        
        if file_path:
            try:
                # Get the preview image path
                sample_path = self.sample_paths[cur_row]
                preview_path = self._preview_cache.get(sample_path)
                
                # Create PDF document
                doc = SimpleDocTemplate(file_path, pagesize=letter)
                story = []
                styles = getSampleStyleSheet()
                
                # Add title
                title_style = ParagraphStyle(
                    'CustomTitle',
                    parent=styles['Heading1'],
                    fontSize=24,
                    textColor=colors.HexColor('#2b3a67'),
                    spaceAfter=30,
                    alignment=1  # Center alignment
                )
                story.append(Paragraph("FTIR Spectroscopy Analysis Report", title_style))
                story.append(Spacer(1, 0.3*inch))
                
                # Add metadata
                metadata_style = ParagraphStyle(
                    'Metadata',
                    parent=styles['Normal'],
                    fontSize=11,
                    textColor=colors.HexColor('#555555'),
                    spaceAfter=12
                )
                story.append(Paragraph(f"<b>Sample:</b> {sample_name}", metadata_style))
                story.append(Paragraph(f"<b>Analysis Date:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", metadata_style))
                story.append(Spacer(1, 0.2*inch))
                
                # Add graph if available
                if preview_path and os.path.exists(preview_path):
                    story.append(Paragraph("<b>Spectral Comparison Graph</b>", styles['Heading2']))
                    story.append(Spacer(1, 0.1*inch))
                    try:
                        img = Image(preview_path, width=6*inch, height=4*inch)
                        story.append(img)
                        story.append(Spacer(1, 0.3*inch))
                    except Exception as e:
                        print(f"Warning: Could Not Embed Image: {e}")
                
                # Add analysis text
                story.append(Paragraph("<b>Analysis Results</b>", styles['Heading2']))
                story.append(Spacer(1, 0.1*inch))
                
                analysis_text = self.ai_analysis_box.toPlainText()
                if analysis_text:
                    # Format the analysis text for PDF
                    analysis_style = ParagraphStyle(
                        'Analysis',
                        parent=styles['Normal'],
                        fontSize=10,
                        leading=14,
                        spaceAfter=12
                    )
                    # Replace newlines with <br/> for proper formatting
                    formatted_text = analysis_text.replace('\n', '<br/>')
                    story.append(Paragraph(formatted_text, analysis_style))
                else:
                    story.append(Paragraph("No Analysis Available", styles['Normal']))
                
                # Build PDF
                doc.build(story)
                QMessageBox.information(self, "Success", f"Analysis Saved To:\n{file_path}")
                self.status_message.setText(f"Analysis Saved: {Path(file_path).name}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Could Not Save PDF: {e}")

    def read_gemini_key(self):
        """Read Gemini API key from GeminiKey.txt file"""
        try:
            with open("GeminiKey.txt", "r") as f:
                return f.read().strip()
        except FileNotFoundError:
            print("GeminiKey.txt not found. AI analysis features will be disabled.")
            return None
        except Exception as e:
            print(f"Error reading GeminiKey.txt: {e}")
            return None

    # ---------- UI callbacks ----------
    def load_baseline(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select Baseline CSV", str(Path.cwd()), "CSV Files (*.csv)")
        if path:
            self.baseline_path = path
            self._preview_cache.clear()  # baseline changed -> invalidate cache
            self.status_message.setText(f"Baseline Loaded: {Path(path).name}")

            # NAV: update breadcrumb - advance to stage 2
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 20px 30px; font-size: 18px;")  # active = green
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage4.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
            except Exception:
                pass


    def load_samples(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select Sample CSVs", str(Path.cwd()), "CSV Files (*.csv)")
        if paths:
            # overwrite previous set per requirements
            self.sample_paths = paths
            self.sample_list.clear()
            for p in paths:
                self.sample_list.addItem(Path(p).name)
            self._preview_cache.clear()  # new samples -> clear cache
            self.status_message.setText(f"{len(paths)} Sample(s) Loaded")

            # NAV: update breadcrumb / progress
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 20px 30px; font-size: 18px;")  # active
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage4.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
            except Exception:
                pass

            # Optionally auto-select first sample
            if len(paths) > 0:
                self.sample_list.setCurrentRow(0)


    def choose_output_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Choose Output Directory", self.output_dir or str(Path.home()))
        if d:
            self.output_dir = d
            self.out_edit.setText(d)
            self.status_message.setText(f"Output Directory: {d}")

    def format_changed(self, text):
        self.image_ext = text

    def select_format(self, fmt):
        """Handle image format button selection and update the current format."""
        self.current_format = fmt
        for f, btn in self.format_buttons.items():
            btn.setChecked(f == fmt)
        self.status_message.setText(f"Image Format Set To {fmt.upper()}")

    def load_r_backend(self):
        # Allow the user to source an R script at runtime (if rpy2 available)
        # This function will try to import rpy2 if it wasn't available at startup,
        # then source the chosen R file and pick up preview_plot / batch_save_plots.
        try:
            # If rpy2 wasn't importable at startup, try again now
            if not USE_R:
                # attempt the same setup function used at module import
                use_r, preview_fn, batch_fn, err = _attempt_setup_rpy2()
                if not use_r:
                    QMessageBox.critical(self, "rpy2 Unavailable", f"rpy2 / R Not Available:\n{err or 'unknown error'}")
                    return
                # set globals from re-check
                globals()['USE_R'] = True
                globals()['r_preview'] = preview_fn
                globals()['r_batch'] = batch_fn

            # Prompt user for an R file to source (optional; user can still use project-local mrg_backend.R)
            path, _ = QFileDialog.getOpenFileName(self, "Select R Backend File", str(Path.cwd()), "R Files (*.R *.r)")
            if not path:
                return

            # source chosen file
            import rpy2.robjects as robjects
            try:
                robjects.r['source'](str(path))
            except Exception as e:
                QMessageBox.critical(self, "R Load Error", f"Could Not Source R File:\n{e}")
                return

            # refresh pointers
            g = robjects.globalenv
            if 'preview_plot' in g:
                self.r_funcs['preview'] = g['preview_plot']
            if 'batch_save_plots' in g:
                self.r_funcs['batch'] = g['batch_save_plots']

            if not self.r_funcs.get('preview') and not self.r_funcs.get('batch'):
                QMessageBox.information(self, "R Backend Loaded", f"Sourced {Path(path).name} But Preview/Batch Functions Not Found.")
            else:
                QMessageBox.information(self, "R Backend Loaded", f"Loaded {Path(path).name}")
                self.status_message.setText("R Backend Loaded")

        except Exception as e:
            QMessageBox.critical(self, "R Load Error", f"Could Not Load R Backend:\n{e}")

    def remove_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0:
            removed = self.sample_paths[cur]
            del self.sample_paths[cur]
            self.sample_list.takeItem(cur)
            # remove from cache if present
            self._preview_cache.pop(removed, None)
            self.status_message.setText(f"Removed Sample: {Path(removed).name}")

            # --- Breadcrumb / progress updates ---
            if not self.sample_paths:
                # No samples left: revert to stage 1 (Load Baseline)
                self.nav_stage1.setStyleSheet("font-weight: 700; color: #28A745; padding: 20px 30px; font-size: 18px;")  # stage 1 = active
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage4.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
            else:
                # Samples remain: keep stage 2 active (Select Sample)
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage2.setStyleSheet("font-weight: 700; color: #28A745; padding: 20px 30px; font-size: 18px;")  # stage 2 = active
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage4.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")


    def preview_selected_sample(self):
        cur = self.sample_list.currentRow()
        if cur >= 0 and self.sample_paths:
            sample_path = self.sample_paths[cur]
            self.generate_and_show_preview(sample_path)
        else:
            QMessageBox.information(self, "No Selection", "Please Select A Sample To Preview.")

    def on_sample_selected(self, row):
        # Auto-generate preview when user changes selection
        if row >= 0 and row < len(self.sample_paths):
            sample_path = self.sample_paths[row]
            
            # Save AI analysis text for previous sample if in text view
            if not self.showing_graph:
                current_sample_path = None
                current_row = self.sample_list.currentRow()
                if 0 <= current_row < len(self.sample_paths):
                    current_sample_path = self.sample_paths[current_row]
                    if current_sample_path and current_sample_path != sample_path:
                        self.ai_analysis_texts[current_sample_path] = self.ai_analysis_box.toPlainText()
            
            # Load AI analysis text for new sample if in text view
            if not self.showing_graph:
                text = self.ai_analysis_texts.get(sample_path, "")
                self.ai_analysis_box.setPlainText(text)
            
            self.generate_and_show_preview(sample_path)

    def show_image_in_preview(self, path):
        if not path or not os.path.exists(path):
            self.preview_label.setText("No Preview Available")
            self.preview_label.setPixmap(QPixmap())  # clear
            return
        pix = QPixmap(path)
        # scale to fit label while keeping aspect
        scaled = pix.scaled(self.preview_label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.preview_label.setPixmap(scaled)

    def generate_preview_path(self, sample_path):
        """
        Return an absolute preview path inside TEMP_DIR for the given sample (or baseline if sample_path is None).
        """
        base_name = Path(self.baseline_path).stem if self.baseline_path else "baseline"
        if sample_path:
            filename = f"preview__{base_name}__{Path(sample_path).stem}.png"
        else:
            filename = f"preview__{base_name}__baseline.png"
        return str(Path(TEMP_DIR) / filename)

    def generate_and_show_preview(self, sample_path):
        """
        Generate a preview for baseline + sample_path.
        Uses R preview_plot(baseline, sample, out_path) if available; otherwise uses python_mock_preview.
        Caches preview image paths for quicker switching.
    
        Usability improvements:
        - Clear messages in the status bar
        - Error popups with guidance
        - Feedback when synthetic/mock data is used
        """
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing Baseline", 
                                "Please Load A Baseline CSV First. "
                                "The Preview Cannot Be Generated Without It.")
            self.status_message.setText("No Baseline Loaded")
            return
    
        # Check if preview is already cached
        if sample_path and sample_path in self._preview_cache and os.path.exists(self._preview_cache[sample_path]):
            self.show_image_in_preview(self._preview_cache[sample_path])
            self.status_message.setText("Preview Loaded From Cache")
            return
        if sample_path is None and '__baseline__' in self._preview_cache and os.path.exists(self._preview_cache['__baseline__']):
            self.show_image_in_preview(self._preview_cache['__baseline__'])
            self.status_message.setText("Preview Loaded From Cache")
            return
    
        # Determine where to write preview
        out_path = self.generate_preview_path(sample_path)
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
    
        try:
            # Try R backend first
            if USE_R and self.r_funcs.get('preview'):
                try:
                    r_sample_arg = sample_path if sample_path else ""
                    self.r_funcs['preview'](self.baseline_path, r_sample_arg, out_path)
                    if os.path.exists(out_path):
                        if sample_path:
                            self._preview_cache[sample_path] = out_path
                        else:
                            self._preview_cache['__baseline__'] = out_path
                        self.show_image_in_preview(out_path)
                        self.status_message.setText("Preview Generated Using R Backend")
                        try:
                            self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                            self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                            self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 20px 30px; font-size: 18px;")
                            self.nav_stage4.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                        except Exception:
                            pass
                        return
                except Exception as e:
                    msg = (f"R Preview Failed: {str(e)}\n"
                           "The Application Will Use A Python Mock Preview Instead.")
                    print(f"[Warning] {msg}")
                    QMessageBox.information(self, "R Preview Warning", msg)
    
            # Fallback to Python mock preview
            python_mock_preview(self.baseline_path, sample_path, out_path)
            if sample_path:
                self._preview_cache[sample_path] = out_path
            else:
                self._preview_cache['__baseline__'] = out_path
            self.show_image_in_preview(out_path)
            self.status_message.setText("Preview Generated Using Python Mock (Synthetic)")
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage3.setStyleSheet("font-weight: 700; color: #28A745; padding: 20px 30px; font-size: 18px;")
                self.nav_stage4.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
            except Exception:
                pass

    
        except Exception as e:
            tb = traceback.format_exc()
            err_msg = (f"Could Not Generate Preview:\n{str(e)}\n\n"
                       "Please Check Your CSV Files And Try Again.")
            print(f"[Error] {err_msg}\n{tb}")
            QMessageBox.critical(self, "Preview Error", err_msg)
            self.status_message.setText("Preview Generation Failed")



    def batch_save(self):
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing Baseline", "Please Load A Baseline CSV First.")
            return
        if not self.sample_paths:
            QMessageBox.warning(self, "Missing Samples", "Please Load Sample CSVs First.")
            return

        out_dir = self.out_edit.text().strip() or self.output_dir

        # Convert to absolute path relative to main.py
        if not os.path.isabs(out_dir):
            base_dir = os.path.dirname(os.path.abspath(__file__))
            out_dir = os.path.join(base_dir, out_dir)

        os.makedirs(out_dir, exist_ok=True)
        ext = getattr(self, "current_format", DEFAULT_IMAGE_EXT)

        # **Ensure output directory exists**
        try:
            os.makedirs(out_dir, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Output Folder Error", f"Could Not Create Output Folder:\n{e}")
            return

        # Keep a reference to the worker to prevent garbage collection
        self.batch_worker = BatchSaveWorker(self.baseline_path, self.sample_paths, out_dir, ext, self.r_funcs)
        self.batch_worker.progress.connect(lambda v: self.progress.setValue(v))
        self.batch_worker.finished.connect(lambda paths, msg: self.on_batch_finished(paths, msg))
        self.batch_worker.error.connect(lambda e: QMessageBox.critical(self, "Batch Save Error", e))
        self.batch_worker.start()
        self.status_message.setText("Batch Save Started...")

    def on_batch_finished(self, paths, msg):
        self.progress.setValue(100)
        self.status_message.setText(msg)
        QMessageBox.information(self, "Batch Save Complete", f"{msg}\nSaved {len(paths)} Files To:\n{self.batch_worker.out_dir}")


    def send_to_gemini(self, image_path=None, prompt="", baseline_csv_path=None, sample_csv_path=None):
        """Send image and/or CSV data with prompt to Gemini API for analysis"""
        if not self.gemini_api_key:
            print("Gemini API key not available. Cannot send request.")
            return None
        
        # Prepare the API request
        url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key={self.gemini_api_key}"
        
        # Create the request payload
        headers = {
            "Content-Type": "application/json"
        }
        
        # Build parts array with prompt as first element
        parts = [{"text": prompt}]
        
        # Add CSV data if paths are provided
        if baseline_csv_path and os.path.exists(baseline_csv_path):
            try:
                with open(baseline_csv_path, "r") as f:
                    baseline_data = f.read()
                parts.append({
                    "text": f"## BASELINE CSV DATA:\n{baseline_data}"
                })
            except Exception as e:
                print(f"Error reading baseline CSV: {e}")
        
        if sample_csv_path and os.path.exists(sample_csv_path):
            try:
                with open(sample_csv_path, "r") as f:
                    sample_data = f.read()
                parts.append({
                    "text": f"## SAMPLE CSV DATA:\n{sample_data}"
                })
            except Exception as e:
                print(f"Error reading sample CSV: {e}")
        
        # Add image if path is provided
        if image_path and os.path.exists(image_path):
            try:
                with open(image_path, "rb") as image_file:
                    encoded_image = base64.b64encode(image_file.read()).decode('utf-8')
                parts.append({
                    "inline_data": {
                        "mime_type": "image/png",
                        "data": encoded_image
                    }
                })
            except Exception as e:
                print(f"Error encoding image: {e}")
        
        data = {
            "contents": [
                {
                    "parts": parts
                }
            ]
        }
        
        try:
            response = requests.post(url, headers=headers, json=data)
            response.raise_for_status()
            result = response.json()
            
            # Extract the generated text
            if "candidates" in result and len(result["candidates"]) > 0:
                return result["candidates"][0]["content"]["parts"][0]["text"]
            else:
                print("No candidates returned from Gemini API")
                return None
        except requests.exceptions.RequestException as e:
            print(f"Error sending request to Gemini API: {e}")
            return None
        except Exception as e:
            print(f"Error processing Gemini API response: {e}")
            return None

    def send_current_to_gemini(self):
        """Send current preview, baseline CSV, and sample CSV to Gemini for FTIR analysis"""
        # Check if we have a baseline
        if not self.baseline_path:
            QMessageBox.warning(self, "Missing Baseline", "Please Load A Baseline CSV First.")
            return
        
        # Get currently selected sample
        cur_row = self.sample_list.currentRow()
        if cur_row < 0 or cur_row >= len(self.sample_paths):
            QMessageBox.warning(self, "No Sample Selected", "Please Select A Sample To Analyze.")
            return
        
        sample_path = self.sample_paths[cur_row]
        
        # Get the preview image path from cache
        preview_path = self._preview_cache.get(sample_path)
        if not preview_path or not os.path.exists(preview_path):
            QMessageBox.warning(self, "No Preview Available", "Please Generate A Preview First.")
            return
        
        # Build the FTIR analysis prompt
        ftir_prompt = """You are an expert in FTIR (Fourier Transform Infrared) spectroscopy analysis for industrial grease condition monitoring. I'm providing you with:

1. A BASELINE CSV file (fresh/reference grease)
2. A SAMPLE CSV file (used grease from machinery)
3. A graph image showing both spectra overlaid

Both CSV files contain two columns:
- Wavenumber (cm⁻¹): typically ranges from ~4000 to ~400 cm⁻¹
- Absorbance: the measured absorption at each wavenumber

Your task is to analyze the spectral differences and provide a comprehensive grease condition assessment.

## ANALYSIS REQUIRED:

### 1. OXIDATION ANALYSIS
- Examine the carbonyl region (1700-1750 cm⁻¹)
- Compare baseline vs sample absorbance in this region
- Calculate or estimate: Oxidation Index = (Peak area at 1700-1750 cm⁻¹ in sample) / (same region in baseline)
- Interpretation: Values >1.5 indicate moderate oxidation, >2.0 severe oxidation

### 2. WATER CONTAMINATION
- Examine the hydroxyl region (3300-3500 cm⁻¹)
- Look for new peaks or increased absorbance in this region
- Quantify the change: "absorbance increased by X%" or "new peak appeared at ~XXXX cm⁻¹"

### 3. ADDITIVE DEPLETION
- Identify any peaks that are LOWER in the sample compared to baseline
- Common additive regions: 1500-1600 cm⁻¹, 1000-1200 cm⁻¹
- Report which peaks decreased and by approximately what percentage

### 4. SOOT/CARBON CONTAMINATION
- Check if the ENTIRE spectrum baseline has shifted upward
- Look for broad, non-specific absorption increase across all wavenumbers
- Report: "baseline elevated by approximately X absorbance units" or "no general elevation detected"

### 5. GLYCOL CONTAMINATION (coolant leaks)
- Check for new or increased peaks at 1000-1100 cm⁻¹ AND 3300-3600 cm⁻¹
- If both regions show increases, glycol contamination is likely

### 6. KEY DIAGNOSTIC RATIOS
- Calculate peak height ratios for major peaks between sample and baseline
- Identify the 3 most significantly changed regions (wavenumber ranges)
- Quantify changes as percentages

### 7. OVERALL SPECTRAL MATCHING SCORE
- Provide an overall similarity score (0-100%, where 100% = identical)
- Use visual assessment and data comparison
- Consider: peak positions, peak heights, overall shape, baseline level

## OUTPUT FORMAT:

Provide your analysis in this structure:

**OVERALL CONDITION SCORE:** [0-100, where 100 = like new]

**SUMMARY:** [2-3 sentence executive summary of grease condition]

**DETAILED FINDINGS:**

1. **Oxidation Status:** [Low/Moderate/High] - [explanation with data]
2. **Water Contamination:** [None/Trace/Moderate/High] - [explanation with data]
3. **Additive Depletion:** [findings]
4. **Soot/Carbon:** [findings]
5. **Glycol Contamination:** [findings]
6. **Most Significant Changes:** [list top 3 wavenumber regions with % change]
7. **Spectral Match Score:** [percentage with explanation]

**RECOMMENDATION:**
- [ ] Continue operation - grease is in good condition
- [ ] Monitor closely - early signs of degradation
- [ ] Schedule regreasing - moderate degradation detected
- [ ] URGENT: Replace immediately - severe contamination/degradation

**MAINTENANCE NOTES:** [specific observations and recommendations]

Please analyze thoroughly using both the numerical CSV data for precision and the graph for visual pattern recognition. Be specific with wavenumber citations and quantitative changes wherever possible."""

        # Show a progress dialog
        progress_dialog = QProgressDialog("Analyzing With Gemini AI...", None, 0, 0, self)
        progress_dialog.setWindowTitle("FTIR Analysis In Progress")
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.setCancelButton(None)
        progress_dialog.show()
        QApplication.processEvents()
        
        # Send to Gemini
        analysis_result = self.send_to_gemini(
            image_path=preview_path,
            prompt=ftir_prompt,
            baseline_csv_path=self.baseline_path,
            sample_csv_path=sample_path
        )
        
        progress_dialog.close()
        
        if analysis_result:
            # Store the analysis result
            self.ai_analysis_texts[sample_path] = analysis_result
            
            # Switch to text view and display the analysis
            self.preview_label.hide()
            self.ai_analysis_box.show()
            self.toggle_button.setText("Show Graph")
            self.showing_graph = False
            self.btn_copy_analysis.show()
            self.btn_save_analysis.show()
            self.ai_analysis_box.setPlainText(analysis_result)
            
            # Update navigation
            try:
                self.nav_stage1.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage2.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage3.setStyleSheet("font-weight: 600; color: #2b3a67; padding: 20px 30px; font-size: 18px;")
                self.nav_stage4.setStyleSheet("font-weight: 700; color: #28A745; padding: 20px 30px; font-size: 18px;")
            except Exception:
                pass
            
            self.status_message.setText("FTIR Analysis Complete - Results Displayed")
            QMessageBox.information(self, "Analysis Complete", "FTIR Analysis Has Been Completed And Displayed In The Text Box.")
        else:
            QMessageBox.critical(self, "Analysis Failed", "Failed To Get Analysis From Gemini. Please Check Your API Key And Try Again.")
            self.status_message.setText("FTIR Analysis Failed")


# -------------------------
# Entry point
# -------------------------
def main():
    # Ensure default output dir exists
    os.makedirs(DEFAULT_SAVE_DIR, exist_ok=True)
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
